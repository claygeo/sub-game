<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Multi-Layer Combat: Submarine → Surface → Aircraft → Underground Cities</title>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            overflow: hidden; 
            background: #000814;
            font-family: 'Courier New', monospace;
            width: 100vw;
            height: 100vh;
        }
        #canvas { 
            display: block; 
            width: 100vw; 
            height: 100vh; 
            position: absolute;
            top: 0;
            left: 0;
        }
        #stats { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            z-index: 100;
        }
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 100;
            max-width: 250px;
            border: 2px solid #4499dd;
        }
        #health-bar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 25px;
            background: rgba(0,0,0,0.8);
            border: 2px solid #4499dd;
            border-radius: 15px;
            padding: 3px;
            z-index: 100;
        }
        #health-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, #33ff33, #66ff66);
            border-radius: 12px;
            transition: width 0.3s ease, background 0.3s ease;
        }
        #health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        .damage-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, rgba(255,0,0,0.4) 0%, rgba(255,0,0,0) 70%);
            pointer-events: none;
            opacity: 0;
            z-index: 99;
            transition: opacity 0.1s;
        }
        #game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 20px;
            display: none;
            z-index: 200;
            border: 2px solid #ff3333;
        }
        #game-over h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff3333;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #game-over button {
            padding: 15px 30px;
            font-size: 18px;
            background: #4499dd;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 20px;
        }
        #game-over button:hover {
            background: #66aaee;
        }
        #debug {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            z-index: 100;
            border: 1px solid #4499dd;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 200px;
            z-index: 150;
            pointer-events: none;
            display: none;
        }
        
        .mobile-btn {
            position: absolute;
            background: rgba(68,153,221,0.3);
            border: 2px solid rgba(68,153,221,0.6);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            touch-action: manipulation;
            user-select: none;
            transition: all 0.1s;
        }
        
        .mobile-btn:active, .mobile-btn.pressed {
            background: rgba(68,153,221,0.6);
            transform: scale(0.95);
        }
        
        /* Movement Controls - Left Side */
        #move-forward { width: 60px; height: 60px; bottom: 120px; left: 70px; }
        #move-left { width: 60px; height: 60px; bottom: 60px; left: 20px; }
        #move-backward { width: 60px; height: 60px; bottom: 60px; left: 70px; }
        #move-right { width: 60px; height: 60px; bottom: 60px; left: 120px; }
        
        /* Depth/Throttle Controls - Center */
        #move-up { width: 50px; height: 50px; bottom: 140px; left: 50%; transform: translateX(-50%); }
        #move-down { width: 50px; height: 50px; bottom: 20px; left: 50%; transform: translateX(-50%); }
        
        /* Action Controls - Right Side */
        #action-left { width: 55px; height: 55px; bottom: 120px; right: 80px; font-size: 12px; }
        #action-right { width: 55px; height: 55px; bottom: 120px; right: 20px; font-size: 12px; }
        #toggle-lights { width: 45px; height: 45px; bottom: 60px; right: 50px; font-size: 12px; }

        /* Layer Indicators */
        .layer-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #ffaa44;
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #ffaa44;
            font-size: 16px;
            font-weight: bold;
            z-index: 150;
            display: none;
            animation: pulse 2s infinite;
            text-align: center;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
        }

        /* Aircraft Selection Interface */
        #aircraft-selection {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f172a 100%);
            display: none;
            z-index: 300;
            color: white;
            font-family: 'Courier New', monospace;
        }

        .hangar-hud {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 90%;
            max-width: 900px;
        }

        .hangar-title {
            font-size: 36px;
            color: #4499dd;
            margin-bottom: 30px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(68,153,221,0.5);
            border-bottom: 2px solid #4499dd;
            padding-bottom: 10px;
        }

        .aircraft-display {
            background: rgba(0,0,0,0.8);
            border: 3px solid #4499dd;
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 0 20px rgba(68,153,221,0.3);
        }

        .aircraft-name {
            font-size: 28px;
            color: #4499dd;
            margin-bottom: 15px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .aircraft-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-item {
            text-align: center;
            background: rgba(68,153,221,0.1);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(68,153,221,0.3);
        }

        .stat-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #4499dd;
        }

        .star-rating {
            color: #ffaa44;
            font-size: 16px;
            margin-top: 5px;
        }

        .aircraft-special {
            background: rgba(255,170,68,0.2);
            border: 2px solid #ffaa44;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            font-style: italic;
            color: #ffaa44;
        }

        .hangar-controls {
            margin-top: 30px;
            font-size: 16px;
        }

        .control-hint {
            margin: 10px 0;
            color: #ccc;
            background: rgba(68,153,221,0.1);
            padding: 8px;
            border-radius: 5px;
        }

        .launch-button {
            background: linear-gradient(45deg, #44aa44, #66cc66);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(68,170,68,0.3);
        }

        .launch-button:hover {
            background: linear-gradient(45deg, #66cc66, #88ee88);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(68,170,68,0.4);
        }

        /* Flight HUD */
        #flight-hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 120;
            display: none;
        }

        .hud-element {
            position: absolute;
            color: #44ff44;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 0 0 5px rgba(68,255,68,0.5);
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid rgba(68,255,68,0.3);
        }

        #altitude-indicator { top: 20px; left: 20px; }
        #speed-indicator { top: 60px; left: 20px; }
        #heading-indicator { top: 100px; left: 20px; }
        #throttle-indicator { bottom: 120px; left: 20px; }
        #stall-warning { top: 140px; left: 20px; color: #ff4444; display: none; }

        .artificial-horizon {
            position: absolute;
            top: 50%;
            right: 50px;
            transform: translateY(-50%);
            width: 120px;
            height: 120px;
            border: 3px solid #44ff44;
            border-radius: 50%;
            background: linear-gradient(to bottom, #4488ff 50%, #8B4513 50%);
            overflow: hidden;
            box-shadow: 0 0 10px rgba(68,255,68,0.3);
        }

        .horizon-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: #44ff44;
            transform-origin: center;
            box-shadow: 0 0 5px rgba(68,255,68,0.5);
        }

        .aircraft-marker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 2px;
            background: #ffaa44;
        }

        .aircraft-marker::before,
        .aircraft-marker::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 2px;
            background: #ffaa44;
            top: 0;
        }

        .aircraft-marker::before { left: -12px; }
        .aircraft-marker::after { right: -12px; }

        #landing-guide {
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: #ffaa44;
            display: none;
            text-align: center;
        }

        /* Transition overlay */
        #transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(ellipse at center, #000000 0%, #001122 100%);
            display: none;
            z-index: 400;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .transition-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4499dd;
            font-size: 24px;
            text-align: center;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(68,153,221,0.8);
        }

        /* Depth indicator */
        #depth-indicator {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #4499dd;
            padding: 10px 20px;
            border-radius: 20px;
            border: 2px solid #4499dd;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
        }

        /* Surface warning */
        .surface-warning {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,170,68,0.9);
            color: #000;
            padding: 15px 25px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            z-index: 150;
            display: none;
            animation: urgent-pulse 1s infinite;
        }

        @keyframes urgent-pulse {
            0%, 100% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        }

        /* City indicators */
        .city-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: #ffaa44;
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid #ffaa44;
            font-size: 16px;
            z-index: 150;
            display: none;
            animation: pulse 2s infinite;
        }

        .boss-indicator {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(100,0,0,0.9);
            color: #ff6666;
            padding: 15px 25px;
            border-radius: 10px;
            border: 3px solid #ff3333;
            font-size: 18px;
            font-weight: bold;
            z-index: 150;
            display: none;
            animation: throb 1.5s infinite;
        }

        @keyframes throb {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        @media (max-width: 768px) {
            #mobile-controls { display: block; }
            #debug { display: none; }
            #info { top: 60px; right: 10px; font-size: 10px; padding: 10px; max-width: 160px; }
            .hangar-title { font-size: 24px; }
            .aircraft-stats { grid-template-columns: 1fr 1fr; }
            .hud-element { font-size: 14px; padding: 6px 8px; }
            .artificial-horizon { width: 100px; height: 100px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="stats"></div>
    
    <div id="health-bar">
        <div id="health-fill"></div>
        <div id="health-text">100 HP</div>
    </div>
    
    <div class="damage-flash" id="damage-flash"></div>
    
    <div class="layer-indicator" id="layer-indicator">
        🌊 Surface Zone Reached - Press C to Break Surface
    </div>

    <div class="surface-warning" id="surface-warning">
        ⚠️ APPROACHING SURFACE - ASCEND TO +150m TO BREAK THROUGH ⚠️
    </div>
    
    <div class="city-indicator" id="city-indicator">
        🏙️ Sinkhole to Lost City - Press C to Descend
    </div>
    
    <div class="boss-indicator" id="boss-indicator">
        ⚠️ ANCIENT GUARDIAN AWAKENING ⚠️
    </div>
    
    <div id="depth-indicator">
        DEPTH: <span id="depth-value">5</span>m
    </div>
    
    <div id="info">
        <div><strong>Layer:</strong> <span id="current-layer">Ocean Depths</span></div>
        <div><strong>Depth:</strong> <span id="depth">5</span>m</div>
        <div><strong>Position:</strong> <span id="position">0, 0</span></div>
        <div><strong>Environment:</strong> <span id="environment">Ocean</span></div>
        <div><strong>Marine Life:</strong> <span id="marine-life">0</span></div>
        <div><strong>Objects:</strong> <span id="objects">0</span></div>
        <div><strong>Torpedoes:</strong> <span id="torpedoes">0</span></div>
        <div><strong>Speed:</strong> <span id="speed">0</span></div>
        <div><strong>Status:</strong> <span id="status">Operational</span></div>
        <div><strong>Cities:</strong> <span id="cities-found">0</span> found</div>
    </div>

    <div id="game-over">
        <h1>MISSION FAILED</h1>
        <p>Lost in the depths...</p>
        <p>Final Status: <span id="final-status">Unknown</span></p>
        <button onclick="location.reload()">Restart Mission</button>
    </div>

    <div id="debug">
        <div><strong>CONTROLS:</strong></div>
        <div>WASD: Move/Fly | Space/Shift: Rise/Sink OR Throttle</div>
        <div>Mouse: Camera/Flight control | Q/E: Fire/Bank</div>
        <div>C: Layer transitions | H: Lights | T: Wireframe</div>
        <div><strong>LAYERS:</strong> Underwater ↔ Surface ↔ Carrier ↔ Aircraft</div>
        <div><strong>CITIES:</strong> Find sinkholes underwater, press C to enter</div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <button class="mobile-btn" id="move-forward">↑</button>
        <button class="mobile-btn" id="move-left">←</button>
        <button class="mobile-btn" id="move-backward">↓</button>
        <button class="mobile-btn" id="move-right">→</button>
        <button class="mobile-btn" id="move-up">▲</button>
        <button class="mobile-btn" id="move-down">▼</button>
        <button class="mobile-btn" id="action-left">Q</button>
        <button class="mobile-btn" id="action-right">E</button>
        <button class="mobile-btn" id="toggle-lights">💡</button>
    </div>

    <!-- Aircraft Selection Interface -->
    <div id="aircraft-selection">
        <div class="hangar-hud">
            <h1 class="hangar-title">🚢 USS ENTERPRISE - AIRCRAFT SELECTION 🚢</h1>
            <div class="aircraft-display" id="aircraft-display">
                <!-- Aircraft info populated by JavaScript -->
            </div>
            <div class="hangar-controls">
                <div class="control-hint">◄ A / D ► Navigate Aircraft Selection</div>
                <div class="control-hint">SPACE or Click Button - Launch Selected Aircraft</div>
                <div class="control-hint">ESC - Return to Surface Navigation</div>
                <button class="launch-button" onclick="launchSelectedAircraft()">🚀 LAUNCH AIRCRAFT 🚀</button>
            </div>
        </div>
    </div>

    <!-- Flight HUD -->
    <div id="flight-hud">
        <div class="hud-element" id="altitude-indicator">ALT: 0m</div>
        <div class="hud-element" id="speed-indicator">SPD: 0 kts</div>
        <div class="hud-element" id="heading-indicator">HDG: 000°</div>
        <div class="hud-element" id="throttle-indicator">THR: 0%</div>
        <div class="hud-element" id="stall-warning">⚠️ STALL WARNING ⚠️</div>
        <div class="hud-element" id="landing-guide">🛬 CARRIER APPROACH - Reduce Speed</div>
        
        <div class="artificial-horizon">
            <div class="horizon-line"></div>
            <div class="aircraft-marker"></div>
        </div>
    </div>

    <!-- Transition Overlay -->
    <div id="transition-overlay">
        <div class="transition-text" id="transition-text">Transitioning...</div>
    </div>

    <!-- CDN Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
    
    <script>
        // ========== ENHANCED SIMPLEX NOISE IMPLEMENTATION ==========
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                             [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                             [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                
                this.p = [];
                for(let i = 0; i < 256; i++) {
                    this.p[i] = Math.floor((seed * 256 * (i + 1)) % 256);
                }
                
                this.perm = [];
                for(let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                }
            }
            
            dot(g, x, y, z = 0) {
                if (!g || g.length < 2) return 0;
                return g[0] * x + g[1] * y + (g[2] || 0) * z;
            }
            
            noise2D(xin, yin) {
                if (!isFinite(xin) || !isFinite(yin)) return 0;
                
                const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
                const s = (xin + yin) * F2;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                
                const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = xin - X0;
                const y0 = yin - Y0;
                
                let i1, j1;
                if (x0 > y0) { i1 = 1; j1 = 0; }
                else { i1 = 0; j1 = 1; }
                
                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;
                
                const ii = i & 255;
                const jj = j & 255;
                
                const gi0 = Math.abs(this.perm[ii + this.perm[jj]]) % 12;
                const gi1 = Math.abs(this.perm[ii + i1 + this.perm[jj + j1]]) % 12;
                const gi2 = Math.abs(this.perm[ii + 1 + this.perm[jj + 1]]) % 12;
                
                const grad0 = this.grad3[gi0] || [1, 1, 0];
                const grad1 = this.grad3[gi1] || [1, 1, 0];
                const grad2 = this.grad3[gi2] || [1, 1, 0];
                
                let t0 = 0.5 - x0 * x0 - y0 * y0;
                let n0 = 0;
                if (t0 >= 0) {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(grad0, x0, y0);
                }
                
                let t1 = 0.5 - x1 * x1 - y1 * y1;
                let n1 = 0;
                if (t1 >= 0) {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(grad1, x1, y1);
                }
                
                let t2 = 0.5 - x2 * x2 - y2 * y2;
                let n2 = 0;
                if (t2 >= 0) {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(grad2, x2, y2);
                }
                
                const result = 70.0 * (n0 + n1 + n2);
                return isFinite(result) ? result : 0;
            }

            noise3D(xin, yin, zin) {
                if (!isFinite(xin) || !isFinite(yin) || !isFinite(zin)) return 0;
                
                const F3 = 1.0 / 3.0;
                const s = (xin + yin + zin) * F3;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                const k = Math.floor(zin + s);
                
                const G3 = 1.0 / 6.0;
                const t = (i + j + k) * G3;
                const X0 = i - t;
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = xin - X0;
                const y0 = yin - Y0;
                const z0 = zin - Z0;
                
                let i1, j1, k1, i2, j2, k2;
                if (x0 >= y0) {
                    if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                    else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
                } else {
                    if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
                    else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
                    else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                }
                
                const x1 = x0 - i1 + G3;
                const y1 = y0 - j1 + G3;
                const z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0 * G3;
                const y2 = y0 - j2 + 2.0 * G3;
                const z2 = z0 - k2 + 2.0 * G3;
                const x3 = x0 - 1.0 + 3.0 * G3;
                const y3 = y0 - 1.0 + 3.0 * G3;
                const z3 = z0 - 1.0 + 3.0 * G3;
                
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                
                const gi0 = Math.abs(this.perm[ii + this.perm[jj + this.perm[kk]]]) % 12;
                const gi1 = Math.abs(this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]]) % 12;
                const gi2 = Math.abs(this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]]) % 12;
                const gi3 = Math.abs(this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]]) % 12;
                
                const grad0 = this.grad3[gi0] || [1, 1, 0];
                const grad1 = this.grad3[gi1] || [1, 1, 0];
                const grad2 = this.grad3[gi2] || [1, 1, 0];
                const grad3 = this.grad3[gi3] || [1, 1, 0];
                
                let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                let n0 = 0;
                if (t0 >= 0) {
                    t0 *= t0;
                    n0 = t0 * t0 * this.dot(grad0, x0, y0, z0);
                }
                
                let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                let n1 = 0;
                if (t1 >= 0) {
                    t1 *= t1;
                    n1 = t1 * t1 * this.dot(grad1, x1, y1, z1);
                }
                
                let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                let n2 = 0;
                if (t2 >= 0) {
                    t2 *= t2;
                    n2 = t2 * t2 * this.dot(grad2, x2, y2, z2);
                }
                
                let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                let n3 = 0;
                if (t3 >= 0) {
                    t3 *= t3;
                    n3 = t3 * t3 * this.dot(grad3, x3, y3, z3);
                }
                
                const result = 32.0 * (n0 + n1 + n2 + n3);
                return isFinite(result) ? result : 0;
            }
        }

        // ========== CUSTOM SHADERS FOR ENHANCED LIGHTING ==========
        const VolumetricLightShader = {
            vertexShader: `
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying vec2 vUv;
                
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 lightPosition;
                uniform vec3 lightColor;
                uniform float lightIntensity;
                uniform vec3 cameraPosition;
                uniform float time;
                uniform sampler2D noiseTexture;
                
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying vec2 vUv;
                
                float noise(vec3 p) {
                    return texture2D(noiseTexture, p.xy * 0.1 + time * 0.02).r;
                }
                
                void main() {
                    vec3 lightDir = normalize(lightPosition - vWorldPosition);
                    float lightDistance = distance(lightPosition, vWorldPosition);
                    float attenuation = 1.0 / (1.0 + 0.09 * lightDistance + 0.032 * lightDistance * lightDistance);
                    
                    // Volumetric light scattering
                    vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                    float scatter = pow(max(0.0, dot(lightDir, viewDir)), 2.0);
                    
                    // Underwater caustics effect
                    float caustic = sin(vWorldPosition.x * 0.2 + time) * sin(vWorldPosition.z * 0.15 + time * 0.8) * 0.3 + 0.7;
                    
                    // Enhanced diffuse lighting with caustics
                    float diff = max(0.0, dot(vNormal, lightDir)) * caustic;
                    
                    // Underwater particle effect
                    float particles = noise(vWorldPosition + time * 0.5) * 0.3;
                    
                    vec3 ambient = vec3(0.1, 0.2, 0.4) * 0.3;
                    vec3 diffuse = lightColor * diff * lightIntensity * attenuation;
                    vec3 scattering = lightColor * scatter * 0.4 * attenuation;
                    
                    vec3 finalColor = ambient + diffuse + scattering + particles * 0.2;
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        };

        const UnderwaterShader = {
            vertexShader: `
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying vec2 vUv;
                
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 lightPosition;
                uniform vec3 lightColor;
                uniform float lightIntensity;
                uniform vec3 cameraPosition;
                uniform float time;
                uniform vec3 baseColor;
                
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying vec2 vUv;
                
                void main() {
                    vec3 lightDir = normalize(lightPosition - vWorldPosition);
                    float lightDistance = distance(lightPosition, vWorldPosition);
                    float attenuation = 1.0 / (1.0 + 0.1 * lightDistance + 0.02 * lightDistance * lightDistance);
                    
                    // Enhanced underwater caustics
                    float caustic1 = sin(vWorldPosition.x * 0.3 + time * 2.0) * sin(vWorldPosition.z * 0.25 + time * 1.5);
                    float caustic2 = sin(vWorldPosition.x * 0.15 + time * -1.2) * sin(vWorldPosition.z * 0.4 + time * 2.3);
                    float caustics = (caustic1 + caustic2) * 0.3 + 0.7;
                    
                    // Depth-based color shift
                    float depth = abs(vWorldPosition.y + 50.0) / 100.0;
                    vec3 depthColor = mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.1, 0.3), depth);
                    
                    float diff = max(0.0, dot(vNormal, lightDir)) * caustics;
                    
                    vec3 ambient = depthColor * 0.4;
                    vec3 diffuse = lightColor * diff * lightIntensity * attenuation;
                    
                    vec3 finalColor = (ambient + diffuse) * baseColor;
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        };

        // ========== GAME STATE MANAGEMENT ==========
        const GAME_LAYERS = {
            UNDERWATER: 'underwater',
            SURFACE: 'surface', 
            CARRIER: 'carrier',
            AIRCRAFT: 'aircraft',
            UNDERGROUND_CITY: 'underground_city'
        };

        // Global game state
        let scene, camera, renderer, stats;
        let currentLayer = GAME_LAYERS.UNDERWATER;
        let isTransitioning = false;
        let gameObjects = {
            submarine: null,
            aircraft: null,
            carrier: null,
            player: null
        };

        // Control state
        let moveForward = false, moveBackward = false, turnLeft = false, turnRight = false;
        let rise = false, sink = false, bankLeft = false, bankRight = false;
        let throttleUp = false, throttleDown = false;
        
        // Camera and input
        let mouseX = 0, mouseY = 0, cameraDistance = 25, cameraAngleH = 0, cameraAngleV = 0.3;
        let isMouseDown = false;
        
        // Performance system
        let objectCount = 0, frameCount = 0, lastPerformanceCheck = 0, adaptiveQuality = 1.0;
        
        // Submarine systems
        let headlightsOn = true, spotlights = [], submarineHealth = 100, maxHealth = 100, isGameOver = false;
        
        // Marine life and combat
        let sharks = [], turtles = [], jellyfish = [], torpedoes = [];
        let kelpForests = [], planktonSystems = [];
        const maxTorpedoes = 6, torpedoSpeed = 2.5, torpedoLifetime = 4000, torpedoCooldown = 400;
        let lastTorpedoTime = 0;

        // Environment generation
        const cellSize = 100, viewRadius = 3;
        const generatedCells = new Map(), cellObjects = new Map();
        const simplex = new SimplexNoise();
        let environment;

        // Enhanced lighting system
        let underwaterLights = [];
        let volumetricMaterial;
        let noiseTexture;

        // Underground city system
        let undergroundCity = {
            sinkholes: new Map(),
            inCity: false,
            nearSinkhole: null,
            exitPortal: null,
            districts: [],
            buildings: [],
            vehicles: [],
            allCityMeshes: [],
            generatedChunks: new Map(),
            currentSeed: null,
            citySize: 600,
            districtTypes: ['ruins', 'industrial', 'residential', 'city_center', 'outskirts'],
            currentDistrict: 'surface',
            bossArena: null,
            bossActive: false,
            cityLights: [],
            debrisFields: [],
            loadedCity: null,
            lastSinkholeCheck: 0
        };

        let citySimplex = null;

        // Layer management system
        const layerManager = {
            savedStates: new Map(),
            
            async transitionTo(newLayer, duration = 2500) {
                if (isTransitioning || newLayer === currentLayer) return false;
                
                console.log(`🔄 Transitioning from ${currentLayer} to ${newLayer}`);
                isTransitioning = true;
                
                // Save current state
                this.saveCurrentState();
                
                // Show transition overlay
                await this.showTransition(this.getTransitionText(currentLayer, newLayer), duration);
                
                // Clean up current layer
                this.cleanupLayer(currentLayer);
                
                // Load new layer
                await this.loadLayer(newLayer);
                
                // Update global state
                currentLayer = newLayer;
                isTransitioning = false;
                
                console.log(`✅ Successfully transitioned to ${newLayer}`);
                return true;
            },
            
            getTransitionText(from, to) {
                const transitions = {
                    [`${GAME_LAYERS.UNDERWATER}_${GAME_LAYERS.SURFACE}`]: '🌊 Breaking Surface...',
                    [`${GAME_LAYERS.SURFACE}_${GAME_LAYERS.CARRIER}`]: '⚓ Docking with Carrier...',
                    [`${GAME_LAYERS.CARRIER}_${GAME_LAYERS.AIRCRAFT}`]: '🚀 Launching Aircraft...',
                    [`${GAME_LAYERS.AIRCRAFT}_${GAME_LAYERS.CARRIER}`]: '🛬 Landing on Carrier...',
                    [`${GAME_LAYERS.SURFACE}_${GAME_LAYERS.UNDERWATER}`]: '🌊 Diving Deep...',
                    [`${GAME_LAYERS.CARRIER}_${GAME_LAYERS.SURFACE}`]: '⚓ Departing Carrier...',
                    [`${GAME_LAYERS.UNDERWATER}_${GAME_LAYERS.UNDERGROUND_CITY}`]: '🏙️ Descending into Lost City...',
                    [`${GAME_LAYERS.UNDERGROUND_CITY}_${GAME_LAYERS.UNDERWATER}`]: '🌊 Ascending to Ocean...'
                };
                return transitions[`${from}_${to}`] || `Transitioning to ${to}...`;
            },
            
            saveCurrentState() {
                const state = {};
                
                switch (currentLayer) {
                    case GAME_LAYERS.UNDERWATER:
                        if (gameObjects.submarine) {
                            state.position = gameObjects.submarine.position.clone();
                            state.rotation = gameObjects.submarine.rotation.clone();
                            state.health = submarineHealth;
                        }
                        break;
                    case GAME_LAYERS.SURFACE:
                        if (gameObjects.submarine) {
                            state.position = gameObjects.submarine.position.clone();
                            state.rotation = gameObjects.submarine.rotation.clone();
                            state.health = submarineHealth;
                        }
                        break;
                    case GAME_LAYERS.AIRCRAFT:
                        if (gameObjects.aircraft) {
                            state.position = gameObjects.aircraft.position.clone();
                            state.rotation = gameObjects.aircraft.rotation.clone();
                            state.aircraftType = selectedAircraftType;
                            state.fuel = aircraftState.fuel;
                            state.speed = aircraftState.speed;
                        }
                        break;
                    case GAME_LAYERS.UNDERGROUND_CITY:
                        if (gameObjects.submarine) {
                            state.position = gameObjects.submarine.position.clone();
                            state.rotation = gameObjects.submarine.rotation.clone();
                            state.health = submarineHealth;
                        }
                        break;
                }
                
                this.savedStates.set(currentLayer, state);
            },
            
            async showTransition(text, duration) {
                const overlay = document.getElementById('transition-overlay');
                const textEl = document.getElementById('transition-text');
                
                textEl.textContent = text;
                overlay.style.display = 'block';
                
                // Fade in
                setTimeout(() => overlay.style.opacity = '1', 50);
                
                await new Promise(resolve => setTimeout(resolve, duration));
                
                // Fade out
                overlay.style.opacity = '0';
                setTimeout(() => overlay.style.display = 'none', 1000);
            },
            
            cleanupLayer(currentLayer) {
                // FIXED: Use the correct parameter name
                switch (currentLayer) {
                    case GAME_LAYERS.UNDERWATER:
                        document.getElementById('surface-warning').style.display = 'none';
                        document.getElementById('city-indicator').style.display = 'none';
                        document.getElementById('layer-indicator').style.display = 'none';
                        
                        // Hide all underwater terrain
                        environment.chunks.forEach(chunk => chunk.visible = false);
                        
                        // Hide all underwater objects and marine life
                        for (const [cellKey, objects] of cellObjects) {
                            [...objects.kelp, ...objects.fish, ...objects.rocks, ...objects.shipwrecks, ...objects.sinkholes, ...objects.plankton].forEach(obj => {
                                obj.visible = false;
                            });
                        }
                        
                        // Hide marine life
                        sharks.forEach(shark => shark.visible = false);
                        turtles.forEach(turtle => turtle.visible = false);
                        jellyfish.forEach(jelly => jelly.visible = false);
                        
                        // Hide plankton systems
                        planktonSystems.forEach(plankton => plankton.visible = false);
                        
                        // Hide torpedoes
                        torpedoes.forEach(torpedo => torpedo.visible = false);
                        
                        console.log('🌊 Cleaned up underwater layer - hidden all entities');
                        break;
                        
                    case GAME_LAYERS.SURFACE:
                        document.getElementById('layer-indicator').style.display = 'none';
                        if (surfaceSystem.waves) {
                            scene.remove(surfaceSystem.waves);
                            surfaceSystem.waves = null;
                        }
                        surfaceSystem.islands.forEach(island => scene.remove(island));
                        surfaceSystem.islands = [];
                        break;
                        
                    case GAME_LAYERS.CARRIER:
                        document.getElementById('aircraft-selection').style.display = 'none';
                        break;
                        
                    case GAME_LAYERS.AIRCRAFT:
                        document.getElementById('flight-hud').style.display = 'none';
                        if (gameObjects.aircraft) {
                            scene.remove(gameObjects.aircraft);
                            gameObjects.aircraft = null;
                        }
                        skySystem.islands.forEach(island => scene.remove(island));
                        skySystem.clouds.forEach(cloud => scene.remove(cloud));
                        skySystem.islands = [];
                        skySystem.clouds = [];
                        break;
                        
                    case GAME_LAYERS.UNDERGROUND_CITY:
                        this.cleanupUndergroundCity();
                        break;
                }
            },
            
            cleanupUndergroundCity() {
                document.getElementById('city-indicator').style.display = 'none';
                document.getElementById('boss-indicator').style.display = 'none';
                
                if (undergroundCity.loadedCity) {
                    scene.remove(undergroundCity.loadedCity);
                    undergroundCity.loadedCity.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    });
                    undergroundCity.loadedCity = null;
                }
                
                if (undergroundCity.exitPortal) {
                    scene.remove(undergroundCity.exitPortal);
                    undergroundCity.exitPortal = null;
                }
                
                undergroundCity.districts.forEach(d => d.generated = false);
                undergroundCity.buildings = [];
                undergroundCity.vehicles = [];
                undergroundCity.allCityMeshes = [];
                undergroundCity.cityLights = [];
                undergroundCity.debrisFields = [];
                undergroundCity.bossArena = null;
                undergroundCity.currentDistrict = 'surface';
                citySimplex = null;
            },
            
            async loadLayer(layer) {
                switch (layer) {
                    case GAME_LAYERS.UNDERWATER:
                        await this.loadUnderwaterLayer();
                        break;
                    case GAME_LAYERS.SURFACE:
                        await this.loadSurfaceLayer();
                        break;
                    case GAME_LAYERS.CARRIER:
                        await this.loadCarrierLayer();
                        break;
                    case GAME_LAYERS.AIRCRAFT:
                        await this.loadAircraftLayer();
                        break;
                    case GAME_LAYERS.UNDERGROUND_CITY:
                        await this.loadUndergroundCityLayer();
                        break;
                }
            },
            
            async loadUnderwaterLayer() {
                // Don't restore position from surface transition - keep current position but adjust depth
                if (gameObjects.submarine) {
                    // When coming from surface, set to a reasonable underwater depth
                    if (gameObjects.submarine.position.y > 100) {
                        gameObjects.submarine.position.y = 50; // Safe underwater depth
                    }
                    gameObjects.player = gameObjects.submarine;
                }
                
                // Show ocean terrain
                environment.chunks.forEach(chunk => chunk.visible = true);
                
                // Show ocean objects
                for (const [cellKey, objects] of cellObjects) {
                    [...objects.kelp, ...objects.fish, ...objects.rocks, ...objects.shipwrecks, ...objects.sinkholes, ...objects.plankton].forEach(obj => {
                        obj.visible = true;
                    });
                }
                
                // Show marine life
                sharks.forEach(shark => shark.visible = true);
                turtles.forEach(turtle => turtle.visible = true);
                jellyfish.forEach(jelly => jelly.visible = true);
                
                // Show plankton systems
                planktonSystems.forEach(plankton => plankton.visible = true);
                
                // Show torpedoes
                torpedoes.forEach(torpedo => torpedo.visible = true);
                
                scene.fog = new THREE.FogExp2(0x002244, 0.004);
                updateLighting('underwater');
                
                document.getElementById('current-layer').textContent = 'Ocean Depths';
                console.log('🌊 Loaded underwater layer - restored all entities');
            },
            
            async loadSurfaceLayer() {
                createSurfaceEnvironment();
                
                if (gameObjects.submarine) {
                    // Position submarine at surface level
                    gameObjects.submarine.position.y = -1;
                    gameObjects.player = gameObjects.submarine;
                }
                
                scene.fog = new THREE.FogExp2(0x87CEEB, 0.0012);
                updateLighting('surface');
                
                document.getElementById('current-layer').textContent = 'Ocean Surface';
                console.log('🌊 Loaded surface layer');
            },
            
            async loadCarrierLayer() {
                document.getElementById('aircraft-selection').style.display = 'block';
                updateAircraftDisplay();
                document.getElementById('current-layer').textContent = 'Aircraft Carrier';
                console.log('⚓ Loaded carrier layer');
            },
            
            async loadAircraftLayer() {
                gameObjects.aircraft = createAircraft(selectedAircraftType);
                
                const carrierPos = gameObjects.carrier ? gameObjects.carrier.position : new THREE.Vector3(0, 10, 0);
                gameObjects.aircraft.position.set(carrierPos.x, carrierPos.y + 15, carrierPos.z - 100);
                gameObjects.aircraft.rotation.y = 0;
                
                scene.add(gameObjects.aircraft);
                gameObjects.player = gameObjects.aircraft;
                
                aircraftState = {
                    speed: aircraftTypes[selectedAircraftType].minSpeed,
                    altitude: carrierPos.y + 15,
                    fuel: 100,
                    throttle: 0.3,
                    banking: 0,
                    pitching: 0,
                    stalled: false,
                    type: selectedAircraftType
                };
                
                document.getElementById('flight-hud').style.display = 'block';
                createSkyEnvironment();
                
                scene.fog = new THREE.FogExp2(0xE6F3FF, 0.0008);
                updateLighting('aircraft');
                
                document.getElementById('current-layer').textContent = `${aircraftTypes[selectedAircraftType].name}`;
                console.log('🚀 Loaded aircraft layer');
            },
            
            async loadUndergroundCityLayer() {
                // Enter underground city
                undergroundCity.inCity = true;
                
                // Clear marine life
                sharks.forEach(shark => scene.remove(shark));
                turtles.forEach(turtle => scene.remove(turtle));
                jellyfish.forEach(jelly => scene.remove(jelly));
                sharks.length = 0;
                turtles.length = 0;
                jellyfish.length = 0;
                
                // Clear torpedoes
                torpedoes.forEach(torpedo => scene.remove(torpedo));
                torpedoes.length = 0;
                
                // Hide ocean objects
                for (const [cellKey, objects] of cellObjects) {
                    [...objects.kelp, ...objects.fish, ...objects.rocks, ...objects.shipwrecks, ...objects.sinkholes].forEach(obj => {
                        obj.visible = false;
                    });
                }
                
                // Hide ocean terrain
                environment.chunks.forEach(chunk => chunk.visible = false);
                
                // Generate city
                const cityLayout = generateUndergroundCity(undergroundCity.nearSinkhole, undergroundCity.nearSinkhole.x * 1000 + undergroundCity.nearSinkhole.z);
                
                if (!undergroundCity.loadedCity) {
                    console.error('City generation failed');
                    undergroundCity.inCity = false;
                    return;
                }
                
                // Safe spawn position
                const spawnX = -40;
                const spawnZ = -40;
                const spawnY = getCityHeight(spawnX, spawnZ) + 10;
                
                gameObjects.submarine.position.set(spawnX, spawnY, spawnZ);
                gameObjects.submarine.rotation.y = 0;
                gameObjects.player = gameObjects.submarine;
                
                // Create exit portal
                createExitPortal(-60, spawnY + 5, -60);
                
                scene.fog = new THREE.FogExp2(0x221133, 0.002);
                updateLighting('underground');
                
                document.getElementById('current-layer').textContent = 'Underground City';
                console.log('🏙️ Loaded underground city layer');
            }
        };

        // Surface layer systems
        const surfaceSystem = {
            waves: null,
            islands: [],
            diveZones: [],
            nearCarrier: false,
            nearDiveZone: null
        };

        // Aircraft system
        let selectedAircraftType = 'fighter';
        let aircraftState = {
            speed: 0,
            altitude: 0,
            fuel: 100,
            throttle: 0,
            banking: 0,
            pitching: 0,
            stalled: false
        };

        const aircraftTypes = {
            fighter: {
                name: 'F-18 Super Hornet',
                maxSpeed: 8.0,
                agility: 0.08,
                minSpeed: 2.0,
                liftCoeff: 1.2,
                dragCoeff: 0.8,
                special: 'Afterburner & Superior Maneuverability',
                stats: { speed: 5, agility: 5, altitude: 4, stability: 3 }
            },
            bomber: {
                name: 'B-52 Stratofortress', 
                maxSpeed: 4.5,
                agility: 0.03,
                minSpeed: 1.8,
                liftCoeff: 1.5,
                dragCoeff: 1.2,
                special: 'High Altitude & Heavy Payload Capacity',
                stats: { speed: 2, agility: 2, altitude: 5, stability: 5 }
            },
            helicopter: {
                name: 'UH-60 Black Hawk',
                maxSpeed: 5.5,
                agility: 0.06,
                minSpeed: 0,
                liftCoeff: 2.0,
                dragCoeff: 1.0,
                special: 'Vertical Flight & Hovering Capability',
                stats: { speed: 3, agility: 4, altitude: 2, stability: 4 }
            }
        };

        // Sky environment
        const skySystem = {
            islands: [],
            clouds: []
        };

        // ========== ENHANCED NOISE TEXTURE GENERATION ==========
        function createNoiseTexture() {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            const imageData = context.createImageData(size, size);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                const noise = Math.random();
                imageData.data[i] = noise * 255;     // Red
                imageData.data[i + 1] = noise * 255; // Green  
                imageData.data[i + 2] = noise * 255; // Blue
                imageData.data[i + 3] = 255;         // Alpha
            }
            
            context.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.generateMipmaps = false;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            
            return texture;
        }

        // ========== TERRAIN GENERATION ==========
        function getHeight(x, z) {
            const scale1 = 0.005;
            const scale2 = 0.01;
            const scale3 = 0.02;
            const scale4 = 0.04;
            
            const baseHeight = simplex.noise2D(x * scale1, z * scale1) * 40;
            const ridges = Math.abs(simplex.noise2D(x * scale2, z * scale2)) * 30;
            const hills = simplex.noise2D(x * scale3, z * scale3) * 20;
            const details = simplex.noise2D(x * scale4, z * scale4) * 10;
            const valleys = -Math.abs(simplex.noise2D(x * 0.003, z * 0.003)) * 25;
            
            return -40 + baseHeight + ridges + hills + details + valleys;
        }

        function getSurfaceHeight(x, z, time = 0) {
            const t = time * 0.001;
            const wave1 = Math.sin(x * 0.02 + t * 2) * 1.2;
            const wave2 = Math.sin(z * 0.015 + t * 1.5) * 0.8;
            const wave3 = Math.sin((x + z) * 0.01 + t * 3) * 0.6;
            const wave4 = Math.sin(x * 0.008 - t * 1.2) * 0.4;
            return wave1 + wave2 + wave3 + wave4;
        }

        function getCityHeight(x, z) {
            if (!citySimplex) return -80;
            
            try {
                const scale1 = 0.003;
                const scale2 = 0.006;
                const scale3 = 0.012;
                
                const baseHeight = citySimplex.noise2D(x * scale1, z * scale1) * 25;
                const streets = Math.abs(citySimplex.noise2D(x * scale2, z * scale2)) * 15;
                const details = citySimplex.noise2D(x * scale3, z * scale3) * 8;
                
                const result = -80 + baseHeight + streets + details;
                return isFinite(result) ? result : -80;
            } catch (error) {
                return -80;
            }
        }

        function createTerrainChunk(size, segments, chunkX, chunkZ) {
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            geometry.rotateX(-Math.PI / 2);
            
            const vertices = geometry.attributes.position.array;
            const colors = new Float32Array(vertices.length);
            
            let minHeight = Infinity;
            let maxHeight = -Infinity;
            
            for (let i = 0; i < vertices.length; i += 3) {
                const localX = vertices[i];
                const localZ = vertices[i + 2];
                const worldX = chunkX * size + localX;
                const worldZ = chunkZ * size + localZ;
                const height = getHeight(worldX, worldZ);
                
                vertices[i + 1] = height;
                minHeight = Math.min(minHeight, height);
                maxHeight = Math.max(maxHeight, height);
            }
            
            for (let i = 0; i < vertices.length; i += 3) {
                const height = vertices[i + 1];
                const normalizedHeight = (height - minHeight) / (maxHeight - minHeight);
                
                const deepColor = { r: 0.08, g: 0.12, b: 0.35 };
                const midColor = { r: 0.15, g: 0.25, b: 0.55 };
                const shallowColor = { r: 0.35, g: 0.45, b: 0.75 };
                
                let color;
                if (normalizedHeight < 0.5) {
                    const t = normalizedHeight * 2;
                    color = {
                        r: deepColor.r + (midColor.r - deepColor.r) * t,
                        g: deepColor.g + (midColor.g - deepColor.g) * t,
                        b: deepColor.b + (midColor.b - deepColor.b) * t
                    };
                } else {
                    const t = (normalizedHeight - 0.5) * 2;
                    color = {
                        r: midColor.r + (shallowColor.r - midColor.r) * t,
                        g: midColor.g + (shallowColor.g - midColor.g) * t,
                        b: midColor.b + (shallowColor.b - midColor.b) * t
                    };
                }
                
                colors[i] = color.r;
                colors[i + 1] = color.g;
                colors[i + 2] = color.b;
            }
            
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            
            // Use enhanced MeshPhongMaterial that works with vertex colors
            const material = new THREE.MeshPhongMaterial({ 
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 50,
                transparent: false,
                opacity: 1.0,
                specular: 0x222244,
                emissive: 0x001122,
                emissiveIntensity: 0.1
            });
            
            const chunk = new THREE.Mesh(geometry, material);
            chunk.receiveShadow = true;
            chunk.userData.isUnderwaterTerrain = true;
            
            return chunk;
        }

        function createEnvironment() {
            const terrainChunks = [];
            const chunkSize = 100;
            const chunksPerSide = 7;
            
            for (let x = 0; x < chunksPerSide; x++) {
                for (let z = 0; z < chunksPerSide; z++) {
                    const chunkX = x - Math.floor(chunksPerSide / 2);
                    const chunkZ = z - Math.floor(chunksPerSide / 2);
                    const chunk = createTerrainChunk(chunkSize, 32, chunkX, chunkZ);
                    chunk.position.set(chunkX * chunkSize, 0, chunkZ * chunkSize);
                    chunk.userData = { chunkX: chunkX, chunkZ: chunkZ };
                    terrainChunks.push(chunk);
                }
            }
            
            return {
                chunks: terrainChunks,
                chunkSize: chunkSize,
                chunksPerSide: chunksPerSide,
                
                updatePosition: function(playerPosition) {
                    if (currentLayer === GAME_LAYERS.UNDERGROUND_CITY) return;
                    
                    const centerChunkX = Math.round(playerPosition.x / chunkSize);
                    const centerChunkZ = Math.round(playerPosition.z / chunkSize);
                    
                    let index = 0;
                    const halfChunks = Math.floor(chunksPerSide / 2);
                    
                    for (let x = 0; x < chunksPerSide; x++) {
                        for (let z = 0; z < chunksPerSide; z++) {
                            const chunkX = centerChunkX + (x - halfChunks);
                            const chunkZ = centerChunkZ + (z - halfChunks);
                            
                            const chunk = terrainChunks[index];
                            const expectedX = chunkX * chunkSize;
                            const expectedZ = chunkZ * chunkSize;
                            
                            if (Math.abs(chunk.position.x - expectedX) > 1 || 
                                Math.abs(chunk.position.z - expectedZ) > 1) {
                                chunk.position.set(expectedX, 0, expectedZ);
                                chunk.userData.chunkX = chunkX;
                                chunk.userData.chunkZ = chunkZ;
                                
                                this.updateChunkGeometry(chunk, chunkX, chunkZ, chunkSize);
                            }
                            
                            index++;
                        }
                    }
                },
                
                updateChunkGeometry: function(chunk, chunkX, chunkZ, chunkSize) {
                    const vertices = chunk.geometry.attributes.position.array;
                    const colors = chunk.geometry.attributes.color.array;
                    
                    let minHeight = Infinity;
                    let maxHeight = -Infinity;
                    
                    for (let i = 0; i < vertices.length; i += 3) {
                        const localX = vertices[i];
                        const localZ = vertices[i + 2];
                        const worldX = chunkX * chunkSize + localX;
                        const worldZ = chunkZ * chunkSize + localZ;
                        const height = getHeight(worldX, worldZ);
                        
                        vertices[i + 1] = height;
                        minHeight = Math.min(minHeight, height);
                        maxHeight = Math.max(maxHeight, height);
                    }
                    
                    for (let i = 0; i < vertices.length; i += 3) {
                        const height = vertices[i + 1];
                        const normalizedHeight = (height - minHeight) / (maxHeight - minHeight);
                        
                        const deepColor = { r: 0.08, g: 0.12, b: 0.35 };
                        const midColor = { r: 0.15, g: 0.25, b: 0.55 };
                        const shallowColor = { r: 0.35, g: 0.45, b: 0.75 };
                        
                        let color;
                        if (normalizedHeight < 0.5) {
                            const t = normalizedHeight * 2;
                            color = {
                                r: deepColor.r + (midColor.r - deepColor.r) * t,
                                g: deepColor.g + (midColor.g - deepColor.g) * t,
                                b: deepColor.b + (midColor.b - deepColor.b) * t
                            };
                        } else {
                            const t = (normalizedHeight - 0.5) * 2;
                            color = {
                                r: midColor.r + (shallowColor.r - midColor.r) * t,
                                g: midColor.g + (shallowColor.g - midColor.g) * t,
                                b: midColor.b + (shallowColor.b - midColor.b) * t
                            };
                        }
                        
                        colors[i] = color.r;
                        colors[i + 1] = color.g;
                        colors[i + 2] = color.b;
                    }
                    
                    chunk.geometry.attributes.position.needsUpdate = true;
                    chunk.geometry.attributes.color.needsUpdate = true;
                    chunk.geometry.computeVertexNormals();
                }
            };
        }

        // ========== OBJECT CREATION ==========
        function createSubmarine() {
            const group = new THREE.Group();
            
            // Main body with enhanced details
            const bodyGeometry = new THREE.CylinderGeometry(1.8, 1.4, 14, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffdd22,
                shininess: 120,
                specular: 0x444444
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            body.castShadow = true;
            group.add(body);
            
            // Enhanced conning tower
            const towerGeometry = new THREE.CylinderGeometry(1.1, 1.1, 4, 8);
            const tower = new THREE.Mesh(towerGeometry, bodyMaterial);
            tower.position.set(0, 2.2, 0);
            tower.castShadow = true;
            group.add(tower);
            
            // Periscope
            const periscopeGeometry = new THREE.CylinderGeometry(0.15, 0.15, 2, 8);
            const periscopeMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 100 });
            const periscope = new THREE.Mesh(periscopeGeometry, periscopeMaterial);
            periscope.position.set(0.5, 4.5, 0);
            group.add(periscope);
            
            // Enhanced propeller system
            const propGroup = new THREE.Group();
            const propBladeGeometry = new THREE.BoxGeometry(0.15, 3, 0.8);
            const propMaterial = new THREE.MeshPhongMaterial({ color: 0x666666, shininess: 100 });
            
            for (let i = 0; i < 4; i++) {
                const blade = new THREE.Mesh(propBladeGeometry, propMaterial);
                blade.rotation.z = (i * Math.PI) / 2;
                propGroup.add(blade);
            }
            propGroup.position.set(0, 0, -8);
            group.propeller = propGroup;
            group.add(propGroup);
            
            // Enhanced windows
            const windowGeometry = new THREE.SphereGeometry(0.4, 12, 12);
            const windowMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x88ccff,
                shininess: 200,
                transparent: true,
                opacity: 0.8
            });
            
            for (let i = 0; i < 6; i++) {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(0, 1, -5 + i * 2);
                window.scale.set(1, 0.8, 0.8);
                group.add(window);
            }
            
            // Enhanced torpedo tubes
            const tubeGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8);
            const tubeMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 100 });
            
            const leftTube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            leftTube.position.set(-2.2, 0, 5);
            leftTube.rotation.x = Math.PI / 2;
            group.add(leftTube);
            
            const rightTube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            rightTube.position.set(2.2, 0, 5);
            rightTube.rotation.x = Math.PI / 2;
            group.add(rightTube);
            
            // Depth rudders
            const rudderGeometry = new THREE.BoxGeometry(0.3, 4, 1.5);
            const rudderMaterial = new THREE.MeshPhongMaterial({ color: 0xffdd22, shininess: 100 });
            
            const topRudder = new THREE.Mesh(rudderGeometry, rudderMaterial);
            topRudder.position.set(0, 2, -6);
            group.add(topRudder);
            
            const bottomRudder = new THREE.Mesh(rudderGeometry, rudderMaterial);
            bottomRudder.position.set(0, -2, -6);
            group.add(bottomRudder);
            
            return group;
        }

        // ========== ENHANCED MARINE LIFE SYSTEM ==========
        function createShark() {
            const group = new THREE.Group();
            
            // Enhanced shark body with better geometry
            const bodyGeometry = new THREE.ConeGeometry(1.8, 10, 16);
            bodyGeometry.rotateX(Math.PI / 2);
            const sharkMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x445566, 
                shininess: 80,
                specular: 0x222222
            });
            const body = new THREE.Mesh(bodyGeometry, sharkMaterial);
            body.castShadow = true;
            group.add(body);
            
            // Enhanced dorsal fin
            const dorsalGeometry = new THREE.ConeGeometry(1.0, 4, 8);
            const dorsalFin = new THREE.Mesh(dorsalGeometry, sharkMaterial);
            dorsalFin.position.set(0, 2.5, -1);
            dorsalFin.rotation.x = -0.3;
            dorsalFin.castShadow = true;
            group.add(dorsalFin);
            
            // Enhanced pectoral fins
            const finGeometry = new THREE.BoxGeometry(4, 0.4, 2.5);
            const leftFin = new THREE.Mesh(finGeometry, sharkMaterial);
            leftFin.position.set(-2.8, -0.5, 0);
            leftFin.rotation.z = -0.5;
            leftFin.rotation.x = -0.2;
            leftFin.castShadow = true;
            group.add(leftFin);
            
            const rightFin = new THREE.Mesh(finGeometry, sharkMaterial);
            rightFin.position.set(2.8, -0.5, 0);
            rightFin.rotation.z = 0.5;
            rightFin.rotation.x = -0.2;
            rightFin.castShadow = true;
            group.add(rightFin);
            
            // Enhanced tail with better shape
            const tailGeometry = new THREE.ConeGeometry(1.5, 4.5, 10);
            const tail = new THREE.Mesh(tailGeometry, sharkMaterial);
            tail.position.set(0, 0.8, -6.5);
            tail.rotation.x = Math.PI / 2;
            tail.castShadow = true;
            group.add(tail);
            
            // Add eyes for more realism
            const eyeGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000, shininess: 200 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.8, 0.3, 4);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.8, 0.3, 4);
            group.add(rightEye);
            
            group.userData = {
                health: 75,
                maxHealth: 75,
                speed: 0.6,
                attackRange: 15,
                attackDamage: 25,
                lastAttackTime: 0,
                attackCooldown: 1500,
                state: 'hunting',
                circleAngle: Math.random() * Math.PI * 2,
                circleRadius: 20 + Math.random() * 15,
                aggroRange: 70,
                type: 'shark',
                swimAnimation: Math.random() * Math.PI * 2,
                huntingPattern: Math.random() < 0.5 ? 'direct' : 'ambush',
                lastSeenPlayerPos: new THREE.Vector3(),
                chaseBoost: 1.0,
                pounceCharging: false,
                pounceTime: 0
            };
            
            return group;
        }

        function createTurtle() {
            const group = new THREE.Group();
            
            // Enhanced shell with better texturing
            const shellGeometry = new THREE.SphereGeometry(2.8, 20, 16);
            shellGeometry.scale(1, 0.6, 1.8);
            const shellMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2d5016, 
                shininess: 60,
                bumpScale: 0.3
            });
            const shell = new THREE.Mesh(shellGeometry, shellMaterial);
            shell.castShadow = true;
            group.add(shell);
            
            // Enhanced head
            const headGeometry = new THREE.SphereGeometry(1.2, 16, 12);
            headGeometry.scale(1.5, 0.8, 2.0);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4a6b2a, 
                shininess: 40 
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0, 3.5);
            head.castShadow = true;
            group.add(head);
            
            // Enhanced flippers with better animation support
            const flipperGeometry = new THREE.BoxGeometry(2.5, 0.6, 3.5);
            const flippers = [];
            for (let i = 0; i < 4; i++) {
                const flipper = new THREE.Mesh(flipperGeometry, headMaterial);
                const angle = (i * Math.PI) / 2;
                flipper.position.set(
                    Math.cos(angle) * 3.2,
                    -1.0,
                    Math.sin(angle) * 1.8
                );
                flipper.rotation.y = angle;
                flipper.castShadow = true;
                group.add(flipper);
                flippers.push(flipper);
            }
            
            group.userData = {
                speed: 0.15,
                wanderAngle: Math.random() * Math.PI * 2,
                wanderRadius: 30 + Math.random() * 25,
                centerX: 0,
                centerZ: 0,
                type: 'turtle',
                swimAnimation: Math.random() * Math.PI * 2,
                avoidanceRadius: 15,
                flippers: flippers,
                currentDirection: new THREE.Vector3()
            };
            
            return group;
        }

        function createJellyfish() {
            const group = new THREE.Group();
            
            // Enhanced bell with translucent material
            const bellGeometry = new THREE.SphereGeometry(2.5, 24, 16);
            bellGeometry.scale(1, 0.7, 1);
            const bellMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x88ccff,
                transparent: true,
                opacity: 0.7,
                shininess: 150,
                emissive: 0x001122
            });
            const bell = new THREE.Mesh(bellGeometry, bellMaterial);
            group.add(bell);
            
            // Enhanced tentacles with more realistic movement
            const tentacleCount = 12;
            const tentacles = [];
            
            for (let i = 0; i < tentacleCount; i++) {
                const tentacleGroup = new THREE.Group();
                const angle = (i / tentacleCount) * Math.PI * 2;
                const radius = 2.0;
                
                const segments = 8;
                const tentacleSegments = [];
                for (let j = 0; j < segments; j++) {
                    const segmentGeometry = new THREE.CylinderGeometry(
                        0.25 - (j * 0.03), 
                        0.25 - ((j + 1) * 0.03), 
                        1.2, 
                        8
                    );
                    const segmentMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x6699cc,
                        transparent: true,
                        opacity: 0.8,
                        emissive: 0x001111
                    });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    segment.position.set(0, -(j + 1) * 1.2, 0);
                    segment.userData = { segmentIndex: j };
                    tentacleGroup.add(segment);
                    tentacleSegments.push(segment);
                }
                
                tentacleGroup.position.set(
                    Math.cos(angle) * radius,
                    -1.8,
                    Math.sin(angle) * radius
                );
                
                tentacleGroup.userData = { 
                    segments: tentacleSegments,
                    baseAngle: angle 
                };
                tentacles.push(tentacleGroup);
                group.add(tentacleGroup);
            }
            
            // Enhanced bioluminescent glow
            const glowLight = new THREE.PointLight(0x88ccff, 2, 30);
            glowLight.position.set(0, 0, 0);
            group.add(glowLight);
            
            group.userData = {
                speed: 0.08,
                pulsePhase: Math.random() * Math.PI * 2,
                driftAngle: Math.random() * Math.PI * 2,
                verticalPhase: Math.random() * Math.PI * 2,
                type: 'jellyfish',
                tentacles: tentacles,
                avoidanceRadius: 12,
                glowLight: glowLight
            };
            
            return group;
        }

        // ========== ENHANCED KELP FOREST SYSTEM ==========
        function createEnhancedKelp(x, z) {
            const group = new THREE.Group();
            const kelpCount = 5 + Math.floor(Math.random() * 8);
            
            for (let i = 0; i < kelpCount; i++) {
                const kelp = new THREE.Group();
                const segments = 12 + Math.floor(Math.random() * 10);
                
                // Create more realistic kelp with individual segments
                const kelpSegments = [];
                let currentHeight = 0;
                const baseRadius = 0.3 + Math.random() * 0.2;
                
                for (let j = 0; j < segments; j++) {
                    const segmentHeight = 1.5 + Math.random() * 1.0;
                    const segmentRadius = baseRadius * (1 - j / segments * 0.7);
                    
                    const segmentGeometry = new THREE.CylinderGeometry(
                        segmentRadius, 
                        segmentRadius * 0.8, 
                        segmentHeight, 
                        8
                    );
                    
                    const kelpMaterial = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color(
                            0.05 + Math.random() * 0.1, 
                            0.25 + Math.random() * 0.2, 
                            0.05 + Math.random() * 0.1
                        ),
                        side: THREE.DoubleSide,
                        shininess: 30,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const segment = new THREE.Mesh(segmentGeometry, kelpMaterial);
                    segment.position.y = currentHeight + segmentHeight / 2;
                    
                    // Add subtle curve to each segment
                    const swayX = Math.sin(j * 0.4) * (j / segments) * 1.5;
                    const swayZ = Math.cos(j * 0.3) * (j / segments) * 1.0;
                    segment.position.x = swayX;
                    segment.position.z = swayZ;
                    
                    segment.userData = {
                        segmentIndex: j,
                        baseSwayX: swayX,
                        baseSwayZ: swayZ,
                        swayAmplitude: 0.3 + Math.random() * 0.4,
                        swaySpeed: 0.8 + Math.random() * 0.6
                    };
                    
                    kelp.add(segment);
                    kelpSegments.push(segment);
                    currentHeight += segmentHeight;
                }
                
                // Add kelp fronds (leaves)
                for (let j = 2; j < segments; j += 2) {
                    const frondGeometry = new THREE.PlaneGeometry(
                        1.0 + Math.random() * 0.5, 
                        2.0 + Math.random() * 1.0
                    );
                    const frondMaterial = new THREE.MeshPhongMaterial({
                        color: new THREE.Color(0.1, 0.4, 0.1),
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    const frond = new THREE.Mesh(frondGeometry, frondMaterial);
                    frond.position.copy(kelpSegments[j].position);
                    frond.position.x += (Math.random() - 0.5) * 1.0;
                    frond.position.z += (Math.random() - 0.5) * 1.0;
                    frond.rotation.y = Math.random() * Math.PI * 2;
                    kelp.add(frond);
                }
                
                kelp.position.set(
                    (Math.random() - 0.5) * 15,
                    0,
                    (Math.random() - 0.5) * 15
                );
                
                kelp.userData = {
                    segments: kelpSegments,
                    swaySpeed: 0.4 + Math.random() * 0.4,
                    swayAmplitude: 0.2 + Math.random() * 0.3,
                    phase: Math.random() * Math.PI * 2,
                    kelpIndex: i
                };
                
                group.add(kelp);
            }
            
            return group;
        }

        // Create enhanced fish school
        function createFishSchool(x, z) {
            const group = new THREE.Group();
            const fishCount = 12 + Math.floor(Math.random() * 16);
            const schoolColor = new THREE.Color(
                0.3 + Math.random() * 0.7,
                0.3 + Math.random() * 0.7,
                0.5 + Math.random() * 0.5
            );
            
            const fishes = [];
            
            for (let i = 0; i < fishCount; i++) {
                const fish = new THREE.Group();
                
                // Enhanced fish body
                const bodyGeometry = new THREE.SphereGeometry(0.6, 12, 8);
                bodyGeometry.scale(3.0, 1.0, 1.2);
                const fishMaterial = new THREE.MeshPhongMaterial({ 
                    color: schoolColor,
                    shininess: 120,
                    specular: 0x333333
                });
                const body = new THREE.Mesh(bodyGeometry, fishMaterial);
                fish.add(body);
                
                // Enhanced tail
                const tailGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
                const tail = new THREE.Mesh(tailGeometry, fishMaterial);
                tail.position.set(-2.0, 0, 0);
                tail.rotation.z = -Math.PI / 2;
                fish.add(tail);
                
                // Fins
                const finGeometry = new THREE.PlaneGeometry(0.4, 0.8);
                const topFin = new THREE.Mesh(finGeometry, fishMaterial);
                topFin.position.set(0, 0.8, 0);
                topFin.rotation.x = Math.PI / 2;
                fish.add(topFin);
                
                const angle = (i / fishCount) * Math.PI * 2;
                const radius = 3 + Math.random() * 4;
                fish.position.set(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 3,
                    Math.sin(angle) * radius
                );
                
                fish.userData = {
                    speed: 1.0 + Math.random() * 0.6,
                    amplitude: 1.2 + Math.random() * 2.0,
                    phase: Math.random() * Math.PI * 2,
                    schoolPosition: new THREE.Vector3(
                        Math.cos(angle) * radius,
                        (Math.random() - 0.5) * 3,
                        Math.sin(angle) * radius
                    )
                };
                
                group.add(fish);
                fishes.push(fish);
            }
            
            group.userData = {
                centerX: x,
                centerZ: z,
                schoolSpeed: 0.4 + Math.random() * 0.3,
                schoolRadius: 18 + Math.random() * 12,
                schoolPhase: Math.random() * Math.PI * 2,
                fishes: fishes
            };
            
            return group;
        }

        // Create rock formation
        function createRockFormation(x, z) {
            const group = new THREE.Group();
            const rockCount = 3 + Math.floor(Math.random() * 5);
            
            for (let i = 0; i < rockCount; i++) {
                const rockGeometry = new THREE.DodecahedronGeometry(
                    2.5 + Math.random() * 4,
                    1
                );
                
                const positions = rockGeometry.attributes.position.array;
                for (let j = 0; j < positions.length; j += 3) {
                    const noise = (Math.random() - 0.5) * 0.4;
                    positions[j] *= (1 + noise);
                    positions[j + 1] *= (1 + noise * 0.6);
                    positions[j + 2] *= (1 + noise);
                }
                rockGeometry.computeVertexNormals();
                
                const rockMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color(
                        0.25 + Math.random() * 0.2,
                        0.25 + Math.random() * 0.15,
                        0.2 + Math.random() * 0.1
                    ),
                    shininess: 15,
                    bumpScale: 0.2
                });
                
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    (Math.random() - 0.5) * 12,
                    Math.random() * 3,
                    (Math.random() - 0.5) * 12
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.castShadow = true;
                rock.receiveShadow = true;
                
                group.add(rock);
            }
            
            return group;
        }

        // Create shipwreck
        function createShipwreck() {
            const group = new THREE.Group();
            
            // Hull
            const hullGeometry = new THREE.CylinderGeometry(4.5, 3.5, 45, 20);
            hullGeometry.scale(1, 0.6, 1);
            const shipMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x3d2914,
                shininess: 10,
                bumpScale: 0.3
            });
            const hull = new THREE.Mesh(hullGeometry, shipMaterial);
            hull.rotation.z = Math.PI / 2;
            hull.position.y = 2;
            group.add(hull);
            
            // Deck
            const deckGeometry = new THREE.BoxGeometry(42, 0.8, 8);
            const deck = new THREE.Mesh(deckGeometry, shipMaterial);
            deck.position.set(0, 5, 0);
            group.add(deck);
            
            // Broken masts
            const mastGeometry = new THREE.CylinderGeometry(0.4, 0.5, 28, 10);
            const mastMaterial = new THREE.MeshPhongMaterial({ color: 0x2d1810 });
            
            const mast1 = new THREE.Mesh(mastGeometry, mastMaterial);
            mast1.position.set(-12, 18, 0);
            mast1.rotation.z = 0.4;
            group.add(mast1);
            
            const mast2 = new THREE.Mesh(mastGeometry, mastMaterial);
            mast2.position.set(10, 16, 0);
            mast2.rotation.z = -0.3;
            group.add(mast2);
            
            // Cabin
            const cabinGeometry = new THREE.BoxGeometry(15, 8, 10);
            const cabin = new THREE.Mesh(cabinGeometry, shipMaterial);
            cabin.position.set(6, 9, 0);
            group.add(cabin);
            
            // Damage holes with darker interior
            const holeGeometry = new THREE.SphereGeometry(2.5, 12, 12);
            const holeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x000000,
                transparent: true,
                opacity: 0.9
            });
            
            const hole1 = new THREE.Mesh(holeGeometry, holeMaterial);
            hole1.position.set(-10, 1, 3.5);
            hole1.scale.set(1, 0.6, 1);
            group.add(hole1);
            
            const hole2 = new THREE.Mesh(holeGeometry, holeMaterial);
            hole2.position.set(15, 2, -2.5);
            hole2.scale.set(0.9, 0.5, 0.9);
            group.add(hole2);
            
            return group;
        }

        // ========== ENHANCED PLANKTON SYSTEM ==========
        function createPlanktonSystem(x, z) {
            const group = new THREE.Group();
            const particleCount = 50 + Math.floor(Math.random() * 30);
            
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // Random position in a volume
                positions[i3] = (Math.random() - 0.5) * 40;
                positions[i3 + 1] = (Math.random() - 0.5) * 20;
                positions[i3 + 2] = (Math.random() - 0.5) * 40;
                
                // Bioluminescent colors
                const colorChoice = Math.random();
                if (colorChoice < 0.3) {
                    colors[i3] = 0.3 + Math.random() * 0.4;     // Red
                    colors[i3 + 1] = 0.8 + Math.random() * 0.2; // Green  
                    colors[i3 + 2] = 1.0;                       // Blue
                } else if (colorChoice < 0.6) {
                    colors[i3] = 0.8 + Math.random() * 0.2;
                    colors[i3 + 1] = 0.9 + Math.random() * 0.1;
                    colors[i3 + 2] = 0.3 + Math.random() * 0.3;
                } else {
                    colors[i3] = 1.0;
                    colors[i3 + 1] = 0.4 + Math.random() * 0.3;
                    colors[i3 + 2] = 0.8 + Math.random() * 0.2;
                }
                
                sizes[i] = 0.5 + Math.random() * 1.5;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.PointsMaterial({
                size: 0.8,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true,
                blending: THREE.AdditiveBlending
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.position.set(x, 0, z);
            
            particles.userData = {
                type: 'plankton',
                driftSpeed: 0.02 + Math.random() * 0.03,
                driftDirection: Math.random() * Math.PI * 2,
                originalPositions: positions.slice(),
                particleCount: particleCount
            };
            
            return particles;
        }

        // ========== SINKHOLE SYSTEM ==========
        function findSinkholes(x, z, radius = 100) {
            const sinkholes = [];
            const step = 60;
            
            for (let dx = -radius; dx <= radius; dx += step) {
                for (let dz = -radius; dz <= radius; dz += step) {
                    const testX = x + dx;
                    const testZ = z + dz;
                    const height = getHeight(testX, testZ);
                    
                    const sinkholeNoise = simplex.noise2D(testX * 0.0008, testZ * 0.0008);
                    const shouldHaveSinkhole = height < -35 || (height < -25 && sinkholeNoise > 0.4);
                    
                    if (shouldHaveSinkhole) {
                        const key = `${Math.floor(testX / 200)}-${Math.floor(testZ / 200)}`;
                        if (!undergroundCity.sinkholes.has(key)) {
                            sinkholes.push({ x: testX, z: testZ, y: height, key: key });
                        }
                    }
                }
            }
            
            return sinkholes;
        }

        function createSinkholeEntrance(x, z, y) {
            const group = new THREE.Group();
            
            // Main sinkhole opening
            const holeGeometry = new THREE.CylinderGeometry(18, 22, 15, 20);
            const holeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x000000,
                transparent: true,
                opacity: 0.95
            });
            const hole = new THREE.Mesh(holeGeometry, holeMaterial);
            hole.position.y = y + 7;
            group.add(hole);
            
            // Cracked earth around sinkhole
            for (let i = 0; i < 15; i++) {
                const angle = (i / 15) * Math.PI * 2;
                const distance = 20 + Math.random() * 18;
                
                const rockGeometry = new THREE.DodecahedronGeometry(2.5 + Math.random() * 5, 1);
                const rockMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color(0.12, 0.08, 0.05),
                    shininess: 10
                });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                
                rock.position.set(
                    Math.cos(angle) * distance,
                    y + Math.random() * 5,
                    Math.sin(angle) * distance
                );
                rock.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                rock.scale.setScalar(1.5 + Math.random() * 1.0);
                
                group.add(rock);
            }
            
            // Enhanced eerie glow from depths
            const innerGlow = new THREE.PointLight(0xffaa44, 3, 100);
            innerGlow.position.set(0, y - 15, 0);
            group.add(innerGlow);
            
            // Mysterious particles rising from the sinkhole
            const particleSystem = createPlanktonSystem(0, 0);
            particleSystem.position.set(0, y - 5, 0);
            particleSystem.scale.setScalar(0.3);
            group.add(particleSystem);
            
            group.userData = {
                type: 'sinkhole_entrance',
                entranceRadius: 25
            };
            
            return group;
        }

        function checkSinkholeProximity() {
            if (undergroundCity.inCity || currentLayer !== GAME_LAYERS.UNDERWATER) return;
            
            const subPos = gameObjects.submarine.position;
            let nearestSinkhole = null;
            let minDistance = Infinity;
            
            for (const [key, sinkhole] of undergroundCity.sinkholes) {
                const distance = subPos.distanceTo(new THREE.Vector3(sinkhole.x, sinkhole.y, sinkhole.z));
                if (distance < 60 && distance < minDistance) {
                    minDistance = distance;
                    nearestSinkhole = { key, ...sinkhole, distance };
                }
            }
            
            const indicator = document.getElementById('city-indicator');
            if (nearestSinkhole && nearestSinkhole.distance < 35) {
                undergroundCity.nearSinkhole = nearestSinkhole;
                indicator.style.display = 'block';
                indicator.textContent = `🏙️ Sinkhole to Lost City ${nearestSinkhole.distance.toFixed(1)}m away - Press C to Descend`;
            } else {
                undergroundCity.nearSinkhole = null;
                indicator.style.display = 'none';
            }
        }

        // ========== UNDERGROUND CITY SYSTEM ==========
        function generateUndergroundCity(sinkholePos, seed) {
            console.log('Generating underground city...');
            
            citySimplex = new SimplexNoise(seed);
            undergroundCity.currentSeed = seed;
            
            // Clear previous city data
            undergroundCity.districts = [];
            undergroundCity.buildings = [];
            undergroundCity.vehicles = [];
            undergroundCity.allCityMeshes = [];
            undergroundCity.cityLights = [];
            undergroundCity.debrisFields = [];
            
            // Create the city group
            const cityGroup = new THREE.Group();
            undergroundCity.loadedCity = cityGroup;
            scene.add(cityGroup);
            
            // Create underground city terrain
            createUndergroundCityTerrain();
            
            // Generate district layout
            const districtSize = 100;
            const districtsPerSide = 5;
            
            for (let dx = 0; dx < districtsPerSide; dx++) {
                for (let dz = 0; dz < districtsPerSide; dz++) {
                    const centerX = (dx - Math.floor(districtsPerSide / 2)) * districtSize;
                    const centerZ = (dz - Math.floor(districtsPerSide / 2)) * districtSize;
                    
                    const districtType = getDistrictType(centerX, centerZ);
                    const districtInfo = {
                        id: `${dx}-${dz}`,
                        type: districtType,
                        centerX: centerX,
                        centerZ: centerZ,
                        size: districtSize,
                        generated: false,
                        buildingCount: 0
                    };
                    
                    undergroundCity.districts.push(districtInfo);
                }
            }
            
            // Generate city center district immediately
            const cityCenter = undergroundCity.districts.find(d => d.type === 'city_center');
            if (cityCenter) {
                generateDistrictContent(cityCenter);
            }
            
            // Add atmospheric lighting
            const cityAmbient = new THREE.AmbientLight(0x332244, 0.4);
            cityAmbient.name = 'cityAmbient';
            cityGroup.add(cityAmbient);
            
            console.log('City generation complete');
            return undergroundCity;
        }

        function createUndergroundCityTerrain() {
            const terrainSize = 600;
            const segments = 30;
            const terrainGeometry = new THREE.PlaneGeometry(terrainSize, terrainSize, segments, segments);
            terrainGeometry.rotateX(-Math.PI / 2);
            
            const vertices = terrainGeometry.attributes.position.array;
            const colors = new Float32Array(vertices.length);
            
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                
                const height = getCityHeight(x, z);
                vertices[i + 1] = height;
                
                const grayValue = 0.15 + Math.random() * 0.1;
                colors[i] = grayValue;
                colors[i + 1] = grayValue;
                colors[i + 2] = grayValue + 0.05;
            }
            
            terrainGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            terrainGeometry.computeVertexNormals();
            
            const terrainMaterial = new THREE.MeshPhongMaterial({
                vertexColors: true,
                shininess: 20
            });
            
            const cityTerrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
            cityTerrain.receiveShadow = true;
            cityTerrain.name = 'cityTerrain';
            
            undergroundCity.loadedCity.add(cityTerrain);
        }

        function getDistrictType(x, z) {
            const centerX = 0;
            const centerZ = 0;
            const distance = Math.sqrt((x - centerX) * (x - centerX) + (z - centerZ) * (z - centerZ));
            
            if (distance < 60) return 'city_center';
            if (distance < 120) return 'residential';
            if (distance < 180) return 'industrial';
            if (distance < 240) return 'ruins';
            return 'outskirts';
        }

        function generateDistrictContent(district) {
            if (district.generated || !undergroundCity.loadedCity) return;
            
            console.log(`Generating ${district.type} district`);
            
            try {
                const buildingDensity = getBuildingDensity(district.type);
                const buildingsToGenerate = Math.floor(buildingDensity * adaptiveQuality);
                
                const gridSize = Math.ceil(Math.sqrt(buildingsToGenerate));
                const cellSize = district.size / gridSize;
                
                for (let i = 0; i < buildingsToGenerate; i++) {
                    const building = generateBuildingForDistrict(district);
                    if (building && undergroundCity.loadedCity) {
                        
                        const gridX = i % gridSize;
                        const gridZ = Math.floor(i / gridSize);
                        
                        const baseX = district.centerX - district.size/2 + (gridX * cellSize) + (cellSize/2);
                        const baseZ = district.centerZ - district.size/2 + (gridZ * cellSize) + (cellSize/2);
                        
                        const offsetX = (Math.random() - 0.5) * cellSize * 0.5;
                        const offsetZ = (Math.random() - 0.5) * cellSize * 0.5;
                        
                        building.position.set(
                            baseX + offsetX,
                            getCityHeight(baseX + offsetX, baseZ + offsetZ),
                            baseZ + offsetZ
                        );
                        
                        building.rotation.y = Math.random() * Math.PI * 2;
                        
                        undergroundCity.loadedCity.add(building);
                        undergroundCity.buildings.push(building);
                        undergroundCity.allCityMeshes.push(building);
                        district.buildingCount++;
                        objectCount++;
                    }
                }
                
                // Special: Add central spire to city center
                if (district.type === 'city_center' && !undergroundCity.bossArena && undergroundCity.loadedCity) {
                    const spire = createCentralSpire();
                    const spireX = district.centerX;
                    const spireZ = district.centerZ;
                    const spireY = getCityHeight(spireX, spireZ);
                    spire.position.set(spireX, spireY, spireZ);
                    
                    undergroundCity.loadedCity.add(spire);
                    undergroundCity.bossArena = spire;
                    undergroundCity.allCityMeshes.push(spire);
                    objectCount++;
                }
                
                district.generated = true;
                console.log(`Generated ${district.type} district with ${district.buildingCount} buildings`);
                
            } catch (error) {
                console.error(`Error generating district ${district.type}:`, error);
                district.generated = true;
            }
        }

        function getBuildingDensity(districtType) {
            switch (districtType) {
                case 'city_center': return 4;
                case 'residential': return 3;
                case 'industrial': return 3;
                case 'ruins': return 2;
                case 'outskirts': return 2;
                default: return 2;
            }
        }

        function generateBuildingForDistrict(district) {
            try {
                switch (district.type) {
                    case 'city_center':
                        return Math.random() > 0.5 ? 
                            createSkyscraper(8 + Math.random() * 4, 30 + Math.random() * 40, 8 + Math.random() * 4, district.type) :
                            createFactory(district.type);
                    case 'residential':
                        return Math.random() > 0.8 ? 
                            createSkyscraper(6 + Math.random() * 2, 15 + Math.random() * 15, 6 + Math.random() * 2, district.type) :
                            createHouse(district.type);
                    case 'industrial':
                        return createFactory(district.type);
                    case 'ruins':
                        return createHouse(district.type);
                    case 'outskirts':
                        return createHouse(district.type);
                    default:
                        return createHouse(district.type);
                }
            } catch (error) {
                console.error('Error generating building:', error);
                return null;
            }
        }

        function createSkyscraper(width, height, depth, district) {
            const group = new THREE.Group();
            
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingMaterial = new THREE.MeshPhongMaterial({
                color: getBuildingColor(district),
                shininess: 50
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height / 2;
            building.castShadow = true;
            building.receiveShadow = true;
            group.add(building);
            
            // Windows
            for (let floor = 1; floor < height / 3; floor++) {
                for (let side = 0; side < 4; side++) {
                    const windowGeometry = new THREE.PlaneGeometry(width * 0.8, 2);
                    const windowMaterial = new THREE.MeshPhongMaterial({
                        color: 0x88ccff,
                        transparent: true,
                        opacity: 0.7,
                        emissive: 0x002244
                    });
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    
                    const angle = (side / 4) * Math.PI * 2;
                    const distance = (side % 2 === 0) ? depth / 2 + 0.1 : width / 2 + 0.1;
                    
                    window.position.set(
                        Math.sin(angle) * distance,
                        floor * 3,
                        Math.cos(angle) * distance
                    );
                    window.rotation.y = angle;
                    group.add(window);
                }
            }
            
            return group;
        }

        function createHouse(district) {
            const group = new THREE.Group();
            
            const width = 6 + Math.random() * 4;
            const height = 5 + Math.random() * 3;
            const depth = 6 + Math.random() * 4;
            
            const houseGeometry = new THREE.BoxGeometry(width, height, depth);
            const houseMaterial = new THREE.MeshPhongMaterial({
                color: getHouseColor(district),
                shininess: 20
            });
            const house = new THREE.Mesh(houseGeometry, houseMaterial);
            house.position.y = height / 2;
            house.castShadow = true;
            house.receiveShadow = true;
            group.add(house);
            
            // Roof
            const roofGeometry = new THREE.ConeGeometry(width * 0.8, height * 0.4, 4);
            const roofMaterial = new THREE.MeshPhongMaterial({
                color: 0x442222,
                shininess: 10
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = height + (height * 0.2);
            roof.rotation.y = Math.PI / 4;
            group.add(roof);
            
            return group;
        }

        function createFactory(district) {
            const group = new THREE.Group();
            
            const width = 15 + Math.random() * 10;
            const height = 12 + Math.random() * 8;
            const depth = 20 + Math.random() * 15;
            
            const factoryGeometry = new THREE.BoxGeometry(width, height, depth);
            const factoryMaterial = new THREE.MeshPhongMaterial({
                color: 0x444444,
                shininess: 10
            });
            const factory = new THREE.Mesh(factoryGeometry, factoryMaterial);
            factory.position.y = height / 2;
            factory.castShadow = true;
            factory.receiveShadow = true;
            group.add(factory);
            
            // Smokestacks
            const stackCount = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < stackCount; i++) {
                const stackGeometry = new THREE.CylinderGeometry(1.5, 2, height * 1.5, 6);
                const stackMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const stack = new THREE.Mesh(stackGeometry, stackMaterial);
                
                stack.position.set(
                    (Math.random() - 0.5) * width * 0.8,
                    height + (height * 0.75),
                    (Math.random() - 0.5) * depth * 0.8
                );
                stack.castShadow = true;
                group.add(stack);
            }
            
            return group;
        }

        function createCentralSpire() {
            const group = new THREE.Group();
            
            const spireGeometry = new THREE.CylinderGeometry(8, 12, 100, 12);
            const spireMaterial = new THREE.MeshPhongMaterial({
                color: 0x444466,
                shininess: 100
            });
            const spire = new THREE.Mesh(spireGeometry, spireMaterial);
            spire.position.y = 50;
            spire.castShadow = true;
            spire.receiveShadow = true;
            group.add(spire);
            
            // Energy core at top
            const coreGeometry = new THREE.SphereGeometry(5, 12, 12);
            const coreMaterial = new THREE.MeshPhongMaterial({
                color: 0x4488ff,
                shininess: 200,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.y = 105;
            group.add(core);
            
            return group;
        }

        function getBuildingColor(district) {
            switch (district) {
                case 'city_center': return 0x666677;
                case 'residential': return 0x775544;
                case 'industrial': return 0x444444;
                case 'ruins': return 0x332222;
                case 'outskirts': return 0x445533;
                default: return 0x555555;
            }
        }

        function getHouseColor(district) {
            switch (district) {
                case 'residential': return 0x887755;
                case 'outskirts': return 0x556644;
                case 'ruins': return 0x443322;
                default: return 0x665544;
            }
        }

        function checkCityCollision(position) {
            if (!undergroundCity.inCity || undergroundCity.allCityMeshes.length === 0) return false;
            
            const safetyMargin = 4;
            
            for (const building of undergroundCity.allCityMeshes) {
                if (building.children && building.children.length > 0) {
                    const buildingDistance = position.distanceTo(building.position);
                    if (buildingDistance > 20) continue;
                    
                    const mainStructure = building.children[0];
                    if (mainStructure && mainStructure.geometry) {
                        const buildingBox = new THREE.Box3().setFromObject(mainStructure);
                        buildingBox.expandByScalar(safetyMargin);
                        
                        if (buildingBox.containsPoint(position)) {
                            return true;
                        }
                    }
                }
            }
            
            const terrainHeight = getCityHeight(position.x, position.z);
            if (position.y <= terrainHeight + 2) {
                return true;
            }
            
            return false;
        }

        function createExitPortal(x, y, z) {
            const group = new THREE.Group();
            
            const platformGeometry = new THREE.CylinderGeometry(12, 14, 2, 12);
            const platformMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x666677,
                shininess: 50
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.set(x, y, z);
            group.add(platform);
            
            const portalGeometry = new THREE.RingGeometry(8, 12, 16);
            const portalMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffaa44,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide,
                shininess: 100
            });
            
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.position.set(x, y + 8, z);
            portal.rotation.x = -Math.PI / 2;
            group.add(portal);
            
            const portalLight = new THREE.PointLight(0xffaa44, 4, 50);
            portalLight.position.set(x, y + 8, z);
            group.add(portalLight);
            
            scene.add(group);
            undergroundCity.exitPortal = group;
            undergroundCity.exitPortal.position.set(x, y, z);
            
            group.userData = {
                type: 'exit_portal',
                exitRadius: 14
            };
        }

        function checkExitProximity() {
            if (!undergroundCity.inCity || !undergroundCity.exitPortal) return;
            
            const distance = gameObjects.submarine.position.distanceTo(undergroundCity.exitPortal.position);
            
            const indicator = document.getElementById('city-indicator');
            if (distance < 30) {
                indicator.style.display = 'block';
                indicator.textContent = `🚪 Surface Portal ${distance.toFixed(1)}m away - Press C to Ascend`;
            } else {
                indicator.style.display = 'none';
            }
        }

        function updateCityGeneration() {
            if (!undergroundCity.inCity || !undergroundCity.loadedCity) return;
            
            const playerPos = gameObjects.submarine.position;
            const generationDistance = 120;
            
            let generatedThisFrame = 0;
            const maxGenerationsPerFrame = 1;
            
            for (const district of undergroundCity.districts) {
                if (!district.generated && generatedThisFrame < maxGenerationsPerFrame) {
                    const distanceToDistrict = Math.sqrt(
                        (playerPos.x - district.centerX) * (playerPos.x - district.centerX) +
                        (playerPos.z - district.centerZ) * (playerPos.z - district.centerZ)
                    );
                    
                    if (distanceToDistrict < generationDistance) {
                        generateDistrictContent(district);
                        generatedThisFrame++;
                    }
                }
            }
            
            const currentDistrict = getCurrentDistrict(playerPos.x, playerPos.z);
            if (currentDistrict && currentDistrict !== undergroundCity.currentDistrict) {
                undergroundCity.currentDistrict = currentDistrict;
            }
            
            if (undergroundCity.bossArena && !undergroundCity.bossActive) {
                const bossDistance = playerPos.distanceTo(undergroundCity.bossArena.position);
                if (bossDistance < 40) {
                    showBossIndicator(true);
                } else {
                    showBossIndicator(false);
                }
            }
        }

        function getCurrentDistrict(x, z) {
            return getDistrictType(x, z);
        }

        function showBossIndicator(show) {
            const indicator = document.getElementById('boss-indicator');
            indicator.style.display = show ? 'block' : 'none';
        }

        // ========== SURFACE SYSTEM ==========
        function createSurfaceEnvironment() {
            console.log('🌊 Creating enhanced surface environment...');
            
            // Create animated ocean surface
            const waveGeometry = new THREE.PlaneGeometry(3000, 3000, 150, 150);
            waveGeometry.rotateX(-Math.PI / 2);
            
            const waveMaterial = new THREE.MeshPhongMaterial({
                color: 0x006699,
                transparent: true,
                opacity: 0.8,
                shininess: 200,
                specular: 0x111111
            });
            
            surfaceSystem.waves = new THREE.Mesh(waveGeometry, waveMaterial);
            scene.add(surfaceSystem.waves);
            
            // Create aircraft carrier
            createAircraftCarrier();
            
            // Create dive zones
            createDiveZones();
            
            // Create some surface islands
            createSurfaceIslands();
            
            console.log('✅ Surface environment created');
        }

        function createAircraftCarrier() {
            const group = new THREE.Group();
            
            // Main hull
            const hullGeometry = new THREE.BoxGeometry(300, 25, 80);
            const hullMaterial = new THREE.MeshPhongMaterial({ color: 0x555555, shininess: 50 });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.position.y = 8;
            hull.castShadow = true;
            group.add(hull);
            
            // Flight deck
            const deckGeometry = new THREE.BoxGeometry(290, 3, 75);
            const deckMaterial = new THREE.MeshPhongMaterial({ color: 0x444444, shininess: 30 });
            const deck = new THREE.Mesh(deckGeometry, deckMaterial);
            deck.position.y = 21;
            deck.castShadow = true;
            group.add(deck);
            
            // Runway markings
            for (let i = 0; i < 8; i++) {
                const lineGeometry = new THREE.BoxGeometry(220, 0.2, 1.5);
                const lineMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x222200 });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(0, 21.2, -30 + i * 8);
                group.add(line);
            }
            
            // Island superstructure
            const islandGeometry = new THREE.BoxGeometry(50, 35, 25);
            const islandMaterial = new THREE.MeshPhongMaterial({ color: 0x666666, shininess: 50 });
            const island = new THREE.Mesh(islandGeometry, islandMaterial);
            island.position.set(100, 35, 0);
            island.castShadow = true;
            group.add(island);
            
            // Control tower
            const towerGeometry = new THREE.BoxGeometry(20, 15, 20);
            const tower = new THREE.Mesh(towerGeometry, islandMaterial);
            tower.position.set(100, 55, 0);
            tower.castShadow = true;
            group.add(tower);
            
            // Radar arrays
            for (let i = 0; i < 4; i++) {
                const radarGeometry = new THREE.CylinderGeometry(1.5, 1.5, 12, 8);
                const radarMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                const radar = new THREE.Mesh(radarGeometry, radarMaterial);
                radar.position.set(100 + (i-1.5) * 12, 70, 0);
                radar.castShadow = true;
                
                const dishGeometry = new THREE.CylinderGeometry(3, 3, 0.5, 16);
                const dish = new THREE.Mesh(dishGeometry, radarMaterial);
                dish.position.y = 6;
                radar.add(dish);
                radar.dish = dish;
                
                group.add(radar);
            }
            
            // Submarine docking bay
            const dockGeometry = new THREE.BoxGeometry(40, 12, 20);
            const dockMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const dock = new THREE.Mesh(dockGeometry, dockMaterial);
            dock.position.set(120, 12, 35);
            group.add(dock);
            
            // Position carrier
            group.position.set(400, 5, 300);
            group.userData = {
                type: 'aircraft_carrier',
                dockingRadius: 50,
                approachRadius: 150
            };
            
            scene.add(group);
            gameObjects.carrier = group;
            
            console.log('⚓ Aircraft carrier created');
        }

        function createDiveZones() {
            const zones = [
                { x: -500, z: -400, name: 'Deep Trench' },
                { x: 600, z: -500, name: 'Abyssal Plain' },
                { x: -400, z: 700, name: 'Hadean Deep' },
                { x: 0, z: -600, name: 'Mariana Access' }
            ];
            
            zones.forEach((pos, index) => {
                const group = new THREE.Group();
                
                const whirlGeometry = new THREE.RingGeometry(20, 35, 24);
                const whirlMaterial = new THREE.MeshPhongMaterial({
                    color: 0x003366,
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const whirl = new THREE.Mesh(whirlGeometry, whirlMaterial);
                whirl.rotation.x = -Math.PI / 2;
                group.add(whirl);
                
                const buoyGeometry = new THREE.CylinderGeometry(2.5, 2.5, 10, 12);
                const buoyMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444, shininess: 100 });
                const buoy = new THREE.Mesh(buoyGeometry, buoyMaterial);
                buoy.position.y = 5;
                buoy.castShadow = true;
                group.add(buoy);
                
                group.position.set(pos.x, 0, pos.z);
                group.userData = {
                    type: 'dive_zone',
                    radius: 40,
                    name: pos.name
                };
                
                scene.add(group);
                surfaceSystem.diveZones.push(group);
            });
        }

        function createSurfaceIslands() {
            for (let i = 0; i < 5; i++) {
                const island = createIsland(30 + Math.random() * 40);
                const angle = (i / 5) * Math.PI * 2;
                const distance = 800 + Math.random() * 400;
                island.position.set(
                    Math.cos(angle) * distance,
                    -5,
                    Math.sin(angle) * distance
                );
                scene.add(island);
                surfaceSystem.islands.push(island);
            }
        }

        function updateSurface() {
            if (currentLayer !== GAME_LAYERS.SURFACE) return;
            
            // Animate waves
            if (surfaceSystem.waves) {
                const time = Date.now();
                const vertices = surfaceSystem.waves.geometry.attributes.position.array;
                
                for (let i = 1; i < vertices.length; i += 3) {
                    const x = vertices[i - 1];
                    const z = vertices[i + 1];
                    vertices[i] = getSurfaceHeight(x, z, time);
                }
                
                surfaceSystem.waves.geometry.attributes.position.needsUpdate = true;
                surfaceSystem.waves.geometry.computeVertexNormals();
            }
            
            // Check carrier proximity
            if (gameObjects.carrier && gameObjects.submarine) {
                const distance = gameObjects.submarine.position.distanceTo(gameObjects.carrier.position);
                
                if (distance < gameObjects.carrier.userData.dockingRadius) {
                    showLayerIndicator('⚓ Press C to Dock with Carrier', true);
                    surfaceSystem.nearCarrier = true;
                } else if (distance < gameObjects.carrier.userData.approachRadius) {
                    showLayerIndicator(`🚢 Aircraft Carrier ${distance.toFixed(0)}m away`, true);
                    surfaceSystem.nearCarrier = false;
                } else {
                    showLayerIndicator('', false);
                    surfaceSystem.nearCarrier = false;
                }
            }
            
            // Check dive zone proximity
            let nearestDiveZone = null;
            let minDistance = Infinity;
            
            for (const zone of surfaceSystem.diveZones) {
                const distance = gameObjects.submarine.position.distanceTo(zone.position);
                if (distance < zone.userData.radius && distance < minDistance) {
                    minDistance = distance;
                    nearestDiveZone = zone;
                }
            }
            
            if (nearestDiveZone && minDistance < 35) {
                surfaceSystem.nearDiveZone = nearestDiveZone;
                if (!surfaceSystem.nearCarrier) {
                    showLayerIndicator(`🌊 ${nearestDiveZone.userData.name} - Press C to Dive`, true);
                }
            } else {
                surfaceSystem.nearDiveZone = null;
            }
            
            // Animate carrier radar
            if (gameObjects.carrier) {
                gameObjects.carrier.children.forEach(child => {
                    if (child.dish) {
                        child.dish.rotation.y += 0.01;
                    }
                });
            }
        }

        // ========== AIRCRAFT SYSTEM ==========
        function createAircraft(type) {
            const group = new THREE.Group();
            const config = aircraftTypes[type];
            
            switch (type) {
                case 'fighter':
                    // Enhanced F-18 Fighter
                    const fuselageGeometry = new THREE.CylinderGeometry(1, 0.5, 14, 12);
                    const fuselageMaterial = new THREE.MeshPhongMaterial({ color: 0x666666, shininess: 100 });
                    const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
                    fuselage.rotation.x = Math.PI / 2;
                    fuselage.castShadow = true;
                    group.add(fuselage);
                    
                    // Wings
                    const wingGeometry = new THREE.BoxGeometry(20, 0.8, 5);
                    const wing = new THREE.Mesh(wingGeometry, fuselageMaterial);
                    wing.position.y = -0.5;
                    wing.castShadow = true;
                    group.add(wing);
                    
                    // Vertical stabilizer
                    const tailGeometry = new THREE.BoxGeometry(0.8, 6, 4);
                    const tail = new THREE.Mesh(tailGeometry, fuselageMaterial);
                    tail.position.set(0, 2, -6);
                    tail.castShadow = true;
                    group.add(tail);
                    
                    // Twin engines
                    for (let i = -1; i <= 1; i += 2) {
                        const engineGeometry = new THREE.CylinderGeometry(0.8, 1, 8, 8);
                        const engine = new THREE.Mesh(engineGeometry, fuselageMaterial);
                        engine.position.set(i * 4, -0.5, -3);
                        engine.rotation.x = Math.PI / 2;
                        engine.castShadow = true;
                        group.add(engine);
                    }
                    break;
                    
                case 'bomber':
                    // Enhanced B-52 Bomber
                    const bomberFuselageGeometry = new THREE.CylinderGeometry(2, 1.5, 25, 12);
                    const bomberMaterial = new THREE.MeshPhongMaterial({ color: 0x777777, shininess: 80 });
                    const bomberFuselage = new THREE.Mesh(bomberFuselageGeometry, bomberMaterial);
                    bomberFuselage.rotation.x = Math.PI / 2;
                    bomberFuselage.castShadow = true;
                    group.add(bomberFuselage);
                    
                    // Massive wings
                    const bomberWingGeometry = new THREE.BoxGeometry(40, 1.5, 10);
                    const bomberWing = new THREE.Mesh(bomberWingGeometry, bomberMaterial);
                    bomberWing.position.y = -1;
                    bomberWing.castShadow = true;
                    group.add(bomberWing);
                    
                    // Eight engines
                    for (let i = -3; i <= 3; i++) {
                        if (i !== 0) {
                            const bomberEngineGeometry = new THREE.CylinderGeometry(0.6, 0.8, 6, 8);
                            const bomberEngine = new THREE.Mesh(bomberEngineGeometry, bomberMaterial);
                            bomberEngine.position.set(i * 6, -2, 0);
                            bomberEngine.rotation.x = Math.PI / 2;
                            bomberEngine.castShadow = true;
                            group.add(bomberEngine);
                        }
                    }
                    
                    // Large vertical stabilizer
                    const bomberTailGeometry = new THREE.BoxGeometry(1, 8, 6);
                    const bomberTail = new THREE.Mesh(bomberTailGeometry, bomberMaterial);
                    bomberTail.position.set(0, 3, -10);
                    bomberTail.castShadow = true;
                    group.add(bomberTail);
                    break;
                    
                case 'helicopter':
                    // Enhanced UH-60 Helicopter
                    const heliBodyGeometry = new THREE.BoxGeometry(5, 4, 15);
                    const heliMaterial = new THREE.MeshPhongMaterial({ color: 0x444444, shininess: 90 });
                    const heliBody = new THREE.Mesh(heliBodyGeometry, heliMaterial);
                    heliBody.castShadow = true;
                    group.add(heliBody);
                    
                    // Main rotor system
                    const rotorGroup = new THREE.Group();
                    const rotorMastGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
                    const rotorMast = new THREE.Mesh(rotorMastGeometry, heliMaterial);
                    rotorMast.position.y = 1;
                    rotorGroup.add(rotorMast);
                    
                    // Four main rotor blades
                    for (let i = 0; i < 4; i++) {
                        const bladeGeometry = new THREE.BoxGeometry(0.3, 0.15, 12);
                        const blade = new THREE.Mesh(bladeGeometry, heliMaterial);
                        blade.position.z = 0;
                        blade.rotation.y = (i * Math.PI) / 2;
                        rotorGroup.add(blade);
                    }
                    rotorGroup.position.y = 4;
                    group.rotorGroup = rotorGroup;
                    group.add(rotorGroup);
                    
                    // Tail boom
                    const tailBoomGeometry = new THREE.BoxGeometry(1.5, 1.5, 12);
                    const tailBoom = new THREE.Mesh(tailBoomGeometry, heliMaterial);
                    tailBoom.position.set(0, 1, -12);
                    tailBoom.castShadow = true;
                    group.add(tailBoom);
                    
                    // Tail rotor system
                    const tailRotorGroup = new THREE.Group();
                    for (let i = 0; i < 4; i++) {
                        const tailBladeGeometry = new THREE.BoxGeometry(0.15, 4, 0.2);
                        const tailBlade = new THREE.Mesh(tailBladeGeometry, heliMaterial);
                        tailBlade.rotation.z = (i * Math.PI) / 2;
                        tailRotorGroup.add(tailBlade);
                    }
                    tailRotorGroup.position.set(2, 1, -18);
                    group.tailRotor = tailRotorGroup;
                    group.add(tailRotorGroup);
                    break;
            }
            
            group.userData = {
                type: 'aircraft',
                aircraftType: type,
                config: config
            };
            
            return group;
        }

        function createSkyEnvironment() {
            console.log('🌤️ Creating sky environment...');
            
            // Create procedural islands
            for (let i = 0; i < 15; i++) {
                const island = createIsland(80 + Math.random() * 120);
                const angle = (i / 15) * Math.PI * 2 + Math.random() * 0.5;
                const distance = 600 + Math.random() * 800;
                island.position.set(
                    Math.cos(angle) * distance,
                    -20 + Math.random() * 40,
                    Math.sin(angle) * distance
                );
                scene.add(island);
                skySystem.islands.push(island);
            }
            
            // Create clouds
            createClouds();
            
            console.log(`✅ Sky environment created with ${skySystem.islands.length} islands and ${skySystem.clouds.length} clouds`);
        }

        function createIsland(size) {
            const group = new THREE.Group();
            
            // Main island terrain
            const islandGeometry = new THREE.CylinderGeometry(size, size * 0.7, 25, 20);
            const islandMaterial = new THREE.MeshPhongMaterial({ color: 0x8B7355, shininess: 30 });
            const island = new THREE.Mesh(islandGeometry, islandMaterial);
            island.castShadow = true;
            island.receiveShadow = true;
            group.add(island);
            
            // Sandy beach
            const beachGeometry = new THREE.CylinderGeometry(size * 1.2, size * 0.9, 3, 20);
            const beachMaterial = new THREE.MeshPhongMaterial({ color: 0xF4A460, shininess: 20 });
            const beach = new THREE.Mesh(beachGeometry, beachMaterial);
            beach.position.y = -11;
            beach.receiveShadow = true;
            group.add(beach);
            
            // Palm trees
            const treeCount = 8 + Math.floor(Math.random() * 15);
            for (let i = 0; i < treeCount; i++) {
                const tree = createPalmTree();
                const angle = Math.random() * Math.PI * 2;
                const radius = size * 0.4 + Math.random() * size * 0.4;
                tree.position.set(
                    Math.cos(angle) * radius,
                    12,
                    Math.sin(angle) * radius
                );
                tree.rotation.y = Math.random() * Math.PI * 2;
                group.add(tree);
            }
            
            return group;
        }

        function createPalmTree() {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.6, 1, 15, 12);
            const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, shininess: 20 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 7.5;
            trunk.castShadow = true;
            group.add(trunk);
            
            // Palm fronds
            for (let i = 0; i < 8; i++) {
                const frondGeometry = new THREE.BoxGeometry(0.8, 0.3, 12);
                const frondMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22, shininess: 50 });
                const frond = new THREE.Mesh(frondGeometry, frondMaterial);
                const angle = (i / 8) * Math.PI * 2;
                frond.position.set(
                    Math.cos(angle) * 6,
                    15,
                    Math.sin(angle) * 6
                );
                frond.rotation.y = angle;
                frond.rotation.z = -0.6;
                frond.castShadow = true;
                group.add(frond);
            }
            
            return group;
        }

        function createClouds() {
            for (let i = 0; i < 30; i++) {
                const cloud = createCloud();
                cloud.position.set(
                    (Math.random() - 0.5) * 3000,
                    120 + Math.random() * 300,
                    (Math.random() - 0.5) * 3000
                );
                scene.add(cloud);
                skySystem.clouds.push(cloud);
            }
        }

        function createCloud() {
            const group = new THREE.Group();
            
            const cloudParts = 6 + Math.floor(Math.random() * 4);
            for (let i = 0; i < cloudParts; i++) {
                const cloudGeometry = new THREE.SphereGeometry(
                    12 + Math.random() * 18, 12, 12
                );
                const cloudMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7 + Math.random() * 0.2
                });
                const cloudPart = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloudPart.position.set(
                    (Math.random() - 0.5) * 50,
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 50
                );
                cloudPart.receiveShadow = true;
                group.add(cloudPart);
            }
            
            group.userData = {
                driftSpeed: 0.03 + Math.random() * 0.03,
                driftDirection: Math.random() * Math.PI * 2,
                verticalBob: Math.random() * 0.02,
                bobPhase: Math.random() * Math.PI * 2
            };
            
            return group;
        }

        function updateAircraft() {
            if (!gameObjects.aircraft || currentLayer !== GAME_LAYERS.AIRCRAFT) return;
            
            const config = aircraftTypes[aircraftState.type];
            const dt = 1/60;
            
            // Throttle control
            if (throttleUp) aircraftState.throttle = Math.min(1, aircraftState.throttle + 0.025);
            if (throttleDown) aircraftState.throttle = Math.max(0, aircraftState.throttle - 0.025);
            
            // Banking (roll) control
            if (bankLeft) aircraftState.banking = Math.max(-1, aircraftState.banking - 0.06);
            if (bankRight) aircraftState.banking = Math.min(1, aircraftState.banking + 0.06);
            if (!bankLeft && !bankRight) aircraftState.banking *= 0.92;
            
            // Pitch control
            if (moveForward) aircraftState.pitching = Math.min(0.6, aircraftState.pitching + 0.04);
            if (moveBackward) aircraftState.pitching = Math.max(-0.6, aircraftState.pitching - 0.04);
            if (!moveForward && !moveBackward) aircraftState.pitching *= 0.92;
            
            // Physics
            const thrust = aircraftState.throttle * config.maxSpeed;
            const drag = aircraftState.speed * config.dragCoeff * 0.1;
            const gravity = aircraftState.type === 'helicopter' ? -0.05 : -0.15;
            
            // Update speed
            aircraftState.speed += (thrust - drag) * dt * 10;
            aircraftState.speed = Math.max(0, aircraftState.speed);
            
            // Lift calculation
            const angleOfAttack = aircraftState.pitching;
            let lift = 0;
            if (aircraftState.speed > 0) {
                lift = (aircraftState.speed * aircraftState.speed * angleOfAttack * config.liftCoeff) / 80;
                const bankingEffect = Math.cos(aircraftState.banking * 0.5);
                lift *= bankingEffect;
            }
            
            // Stall detection
            aircraftState.stalled = aircraftState.speed < config.minSpeed && aircraftState.type !== 'helicopter';
            if (aircraftState.stalled) {
                document.getElementById('stall-warning').style.display = 'block';
                lift *= 0.2;
            } else {
                document.getElementById('stall-warning').style.display = 'none';
            }
            
            // Apply forces
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(gameObjects.aircraft.quaternion);
            const up = new THREE.Vector3(0, 1, 0);
            
            gameObjects.aircraft.position.add(forward.multiplyScalar(aircraftState.speed * dt * 10));
            gameObjects.aircraft.position.add(up.multiplyScalar((lift + gravity) * dt * 10));
            
            // Rotation
            if (Math.abs(aircraftState.banking) > 0.1) {
                gameObjects.aircraft.rotateY(-aircraftState.banking * config.agility * dt * 10);
            }
            
            // Apply pitch and bank
            gameObjects.aircraft.rotation.x = aircraftState.pitching * 0.4;
            gameObjects.aircraft.rotation.z = aircraftState.banking * 0.6;
            
            // Update altitude
            aircraftState.altitude = gameObjects.aircraft.position.y;
            
            // Terrain collision
            const terrainHeight = 5;
            if (gameObjects.aircraft.position.y < terrainHeight + 3) {
                if (aircraftState.speed > config.minSpeed * 2.5) {
                    damageAircraft(100);
                } else {
                    gameObjects.aircraft.position.y = terrainHeight + 3;
                    aircraftState.speed *= 0.85;
                }
            }
            
            // Helicopter handling
            if (aircraftState.type === 'helicopter') {
                if (rise) gameObjects.aircraft.position.y += 0.8;
                if (sink) gameObjects.aircraft.position.y -= 0.8;
                
                if (gameObjects.aircraft.rotorGroup) {
                    gameObjects.aircraft.rotorGroup.rotation.y += 0.6;
                }
                if (gameObjects.aircraft.tailRotor) {
                    gameObjects.aircraft.tailRotor.rotation.x += 1.0;
                }
            }
            
            updateFlightHUD();
        }

        function checkCarrierLanding() {
            if (currentLayer !== GAME_LAYERS.AIRCRAFT || !gameObjects.carrier || !gameObjects.aircraft) return;
            
            const distance = gameObjects.aircraft.position.distanceTo(gameObjects.carrier.position);
            const altitude = gameObjects.aircraft.position.y - gameObjects.carrier.position.y;
            
            if (distance < 150 && altitude < 80) {
                document.getElementById('landing-guide').style.display = 'block';
                
                if (distance < 40 && altitude < 25 && aircraftState.speed < aircraftTypes[aircraftState.type].maxSpeed * 0.4) {
                    showLayerIndicator('🛬 Carrier Landing Available - Press C to Land', true);
                } else {
                    showLayerIndicator('', false);
                }
            } else {
                document.getElementById('landing-guide').style.display = 'none';
                showLayerIndicator('', false);
            }
        }

        // ========== TORPEDO SYSTEM ==========
        function createTorpedo() {
            const group = new THREE.Group();
            
            // Enhanced torpedo body
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.3, 4, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x444444, shininess: 100 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            body.castShadow = true;
            group.add(body);
            
            // Nose cone
            const noseGeometry = new THREE.ConeGeometry(0.4, 1.2, 8);
            const nose = new THREE.Mesh(noseGeometry, bodyMaterial);
            nose.position.set(0, 0, 2.6);
            nose.rotation.x = -Math.PI / 2;
            nose.castShadow = true;
            group.add(nose);
            
            // Fins
            for (let i = 0; i < 4; i++) {
                const finGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.8);
                const fin = new THREE.Mesh(finGeometry, bodyMaterial);
                const angle = (i * Math.PI) / 2;
                fin.position.set(
                    Math.cos(angle) * 0.5,
                    Math.sin(angle) * 0.5,
                    -1.8
                );
                fin.rotation.z = angle;
                group.add(fin);
            }
            
            // Propulsion trail
            const trailLight = new THREE.PointLight(0xffaa00, 2, 15);
            trailLight.position.set(0, 0, -2.5);
            group.add(trailLight);
            
            return group;
        }

        function fireTorpedo(side = 'left') {
            if (isGameOver || (currentLayer !== GAME_LAYERS.UNDERWATER && currentLayer !== GAME_LAYERS.UNDERGROUND_CITY)) return;
            
            const currentTime = Date.now();
            if (torpedoes.length >= maxTorpedoes || currentTime - lastTorpedoTime < torpedoCooldown) return;
            
            lastTorpedoTime = currentTime;
            
            const torpedo = createTorpedo();
            torpedo.position.copy(gameObjects.submarine.position);
            torpedo.position.y -= 0.8;
            torpedo.position.x += side === 'left' ? -2.5 : 2.5;
            torpedo.position.z += 5;
            
            const direction = new THREE.Vector3(0, 0, 1).applyQuaternion(gameObjects.submarine.quaternion);
            torpedo.quaternion.copy(gameObjects.submarine.quaternion);
            
            torpedo.userData = {
                velocity: direction.multiplyScalar(torpedoSpeed),
                spawnTime: currentTime
            };
            
            scene.add(torpedo);
            torpedoes.push(torpedo);
            
            console.log(`🚀 Torpedo fired from ${side} tube`);
        }

        function updateTorpedoes() {
            for (let i = torpedoes.length - 1; i >= 0; i--) {
                const torpedo = torpedoes[i];
                const userData = torpedo.userData;
                const currentTime = Date.now();
                
                torpedo.position.add(userData.velocity);
                
                let hit = false;
                
                // Environment collision
                if (currentLayer === GAME_LAYERS.UNDERWATER) {
                    const terrainHeight = getHeight(torpedo.position.x, torpedo.position.z);
                    if (torpedo.position.y <= terrainHeight + 2) {
                        hit = true;
                    }
                } else if (currentLayer === GAME_LAYERS.UNDERGROUND_CITY) {
                    if (checkCityCollision(torpedo.position)) {
                        hit = true;
                    }
                }
                
                const expired = currentTime - userData.spawnTime > torpedoLifetime;
                
                // Shark collision detection
                sharks.forEach((shark, sharkIndex) => {
                    if (shark.userData.health > 0) {
                        const distance = torpedo.position.distanceTo(shark.position);
                        if (distance < 5) {
                            shark.userData.health -= 50;
                            if (shark.userData.health <= 0) {
                                scene.remove(shark);
                                sharks.splice(sharkIndex, 1);
                                console.log('🦈 Shark eliminated by torpedo!');
                            }
                            hit = true;
                        }
                    }
                });
                
                if (hit || expired) {
                    createExplosion(torpedo.position);
                    scene.remove(torpedo);
                    torpedoes.splice(i, 1);
                }
            }
        }

        // ========== EXPLOSION SYSTEM ==========
        function createExplosion(position) {
            const group = new THREE.Group();
            
            // Main explosion sphere
            const explosionGeometry = new THREE.SphereGeometry(1.5, 12, 12);
            const explosionMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffaa00,
                transparent: true,
                opacity: 0.9,
                emissive: 0x442200
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            group.add(explosion);
            
            // Particle effects
            for (let i = 0; i < 12; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 6, 6);
                const particleMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0x221100
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                const angle = Math.random() * Math.PI * 2;
                const elevation = (Math.random() - 0.5) * Math.PI;
                const distance = 1.5 + Math.random() * 3;
                
                particle.position.set(
                    Math.cos(angle) * Math.cos(elevation) * distance,
                    Math.sin(elevation) * distance,
                    Math.sin(angle) * Math.cos(elevation) * distance
                );
                
                particle.userData = {
                    velocity: particle.position.clone().normalize().multiplyScalar(0.3),
                    life: 1.0,
                    decay: 0.035
                };
                
                group.add(particle);
            }
            
            // Enhanced lighting
            const explosionLight = new THREE.PointLight(0xffaa00, 5, 40);
            group.add(explosionLight);
            
            group.position.copy(position);
            group.userData = {
                life: 1.0,
                maxScale: 8,
                decay: 0.025
            };
            
            scene.add(group);
        }

        function updateExplosions() {
            const explosions = scene.children.filter(obj => obj.userData && obj.userData.maxScale !== undefined);
            
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                const userData = explosion.userData;
                
                const scale = (1 - userData.life) * userData.maxScale;
                explosion.scale.setScalar(scale);
                
                explosion.children.forEach(child => {
                    if (child.userData && child.userData.velocity) {
                        child.position.add(child.userData.velocity);
                        child.userData.life -= child.userData.decay;
                        if (child.material) {
                            child.material.opacity = Math.max(0, child.userData.life);
                        }
                    }
                });
                
                userData.life -= userData.decay;
                
                if (userData.life <= 0) {
                    scene.remove(explosion);
                }
            }
        }

        // ========== ENHANCED UPDATE FUNCTIONS ==========
        function updateSubmarine() {
            if (!gameObjects.submarine || currentLayer === GAME_LAYERS.AIRCRAFT) return;
            
            const speed = 0.6;
            const turnSpeed = 0.06;
            const verticalSpeed = 0.4;
            
            const prevPosition = gameObjects.submarine.position.clone();
            
            // Movement
            if (moveForward) {
                const direction = new THREE.Vector3(0, 0, 1).applyQuaternion(gameObjects.submarine.quaternion);
                gameObjects.submarine.position.add(direction.multiplyScalar(speed));
            }
            if (moveBackward) {
                const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(gameObjects.submarine.quaternion);
                gameObjects.submarine.position.add(direction.multiplyScalar(speed * 0.7));
            }
            if (turnLeft) gameObjects.submarine.rotateY(turnSpeed);
            if (turnRight) gameObjects.submarine.rotateY(-turnSpeed);
            
            // Depth system
            if (currentLayer === GAME_LAYERS.UNDERWATER) {
                if (rise) gameObjects.submarine.position.y += verticalSpeed;
                if (sink) gameObjects.submarine.position.y -= verticalSpeed;
                
                // Check for surface approach
                if (gameObjects.submarine.position.y >= 120) {
                    document.getElementById('surface-warning').style.display = 'block';
                    
                    if (gameObjects.submarine.position.y >= 150) {
                        showLayerIndicator('🌊 Surface Zone Reached - Press C to Break Surface', true);
                    }
                } else {
                    document.getElementById('surface-warning').style.display = 'none';
                }
                
            } else if (currentLayer === GAME_LAYERS.SURFACE) {
                const waveHeight = getSurfaceHeight(gameObjects.submarine.position.x, gameObjects.submarine.position.z, Date.now());
                gameObjects.submarine.position.y = -1 + waveHeight;
            } else if (currentLayer === GAME_LAYERS.UNDERGROUND_CITY) {
                if (rise) gameObjects.submarine.position.y += verticalSpeed;
                if (sink) gameObjects.submarine.position.y -= verticalSpeed;
                
                // City collision detection
                if (checkCityCollision(gameObjects.submarine.position)) {
                    gameObjects.submarine.position.copy(prevPosition);
                }
                
                const cityTerrainHeight = getCityHeight(gameObjects.submarine.position.x, gameObjects.submarine.position.z);
                gameObjects.submarine.position.y = Math.max(gameObjects.submarine.position.y, cityTerrainHeight + 3);
            }
            
            // Propeller animation
            if (gameObjects.submarine.propeller && (moveForward || moveBackward)) {
                gameObjects.submarine.propeller.rotation.z += 0.4 * (moveForward ? 1 : -1);
            }
            
            // Collision detection for ocean layers
            if (currentLayer === GAME_LAYERS.UNDERWATER || currentLayer === GAME_LAYERS.SURFACE) {
                const terrainHeight = getHeight(gameObjects.submarine.position.x, gameObjects.submarine.position.z);
                gameObjects.submarine.position.y = Math.max(gameObjects.submarine.position.y, terrainHeight + 4);
                
                // Update terrain chunks
                if (frameCount % 30 === 0) {
                    environment.updatePosition(gameObjects.submarine.position);
                }
            }
        }

        function spawnMarineLife() {
            if (currentLayer !== GAME_LAYERS.UNDERWATER) return;
            
            const subPos = gameObjects.submarine.position;
            const spawnMultiplier = adaptiveQuality;
            
            // Enhanced shark spawning with guaranteed minimum
            if (sharks.length < Math.floor(3 * spawnMultiplier) && Math.random() < 0.012 * spawnMultiplier) {
                const shark = createShark();
                const angle = Math.random() * Math.PI * 2;
                const distance = 40 + Math.random() * 50;
                shark.position.set(
                    subPos.x + Math.cos(angle) * distance,
                    subPos.y + (Math.random() - 0.5) * 25,
                    subPos.z + Math.sin(angle) * distance
                );
                scene.add(shark);
                sharks.push(shark);
                console.log(`🦈 Shark spawned at distance ${distance.toFixed(1)}m`);
            }
            
            // Force spawn at least one shark if none exist
            if (sharks.length === 0 && Math.random() < 0.02) {
                const shark = createShark();
                const angle = Math.random() * Math.PI * 2;
                const distance = 60;
                shark.position.set(
                    subPos.x + Math.cos(angle) * distance,
                    subPos.y + (Math.random() - 0.5) * 20,
                    subPos.z + Math.sin(angle) * distance
                );
                scene.add(shark);
                sharks.push(shark);
                console.log('🦈 Force-spawned shark to ensure presence');
            }
            
            if (turtles.length < Math.floor(2 * spawnMultiplier) && Math.random() < 0.006 * spawnMultiplier) {
                const turtle = createTurtle();
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 35;
                turtle.position.set(
                    subPos.x + Math.cos(angle) * distance,
                    subPos.y + (Math.random() - 0.5) * 20,
                    subPos.z + Math.sin(angle) * distance
                );
                turtle.userData.centerX = turtle.position.x;
                turtle.userData.centerZ = turtle.position.z;
                scene.add(turtle);
                turtles.push(turtle);
            }
            
            if (jellyfish.length < Math.floor(3 * spawnMultiplier) && Math.random() < 0.008 * spawnMultiplier) {
                const jelly = createJellyfish();
                const angle = Math.random() * Math.PI * 2;
                const distance = 25 + Math.random() * 30;
                jelly.position.set(
                    subPos.x + Math.cos(angle) * distance,
                    subPos.y + (Math.random() - 0.5) * 30,
                    subPos.z + Math.sin(angle) * distance
                );
                scene.add(jelly);
                jellyfish.push(jelly);
            }
        }

        // ========== ENHANCED SHARK AI SYSTEM ==========
        function updateSharkAI(shark, time) {
            if (currentLayer !== GAME_LAYERS.UNDERWATER || !gameObjects.submarine) return;
            
            const userData = shark.userData;
            if (userData.health <= 0) return;
            
            const toSubmarine = new THREE.Vector3().subVectors(gameObjects.submarine.position, shark.position);
            const distance = toSubmarine.length();
            
            // Enhanced AI state machine
            if (distance > userData.aggroRange) {
                userData.state = 'hunting';
            } else if (distance < userData.attackRange && userData.state !== 'pounceCharging') {
                if (userData.huntingPattern === 'ambush' && Math.random() < 0.015) {
                    userData.state = 'pounceCharging';
                    userData.pounceTime = time;
                    userData.chaseBoost = 2.5;
                } else {
                    userData.state = 'attacking';
                }
            } else if (distance < 35) {
                userData.state = 'circling';
            }
            
            // Add visual warning glow when shark is aggressive
            if (userData.state === 'attacking' || userData.state === 'pounceCharging') {
                if (!shark.userData.warningGlow) {
                    const warningGlow = new THREE.PointLight(0xff4444, 2, 30);
                    warningGlow.position.set(0, 0, 0);
                    shark.add(warningGlow);
                    shark.userData.warningGlow = warningGlow;
                }
            } else if (shark.userData.warningGlow) {
                shark.remove(shark.userData.warningGlow);
                shark.userData.warningGlow = null;
            }
            
            // Enhanced swimming animation
            userData.swimAnimation += 0.08;
            shark.rotation.z = Math.sin(userData.swimAnimation) * 0.2;
            shark.rotation.x = Math.sin(userData.swimAnimation * 0.7) * 0.1;
            
            // Update last seen player position for smarter tracking
            if (distance < userData.aggroRange) {
                userData.lastSeenPlayerPos.copy(gameObjects.submarine.position);
            }
            
            switch (userData.state) {
                case 'hunting':
                    // Patrol behavior - move towards last known position
                    const huntTarget = userData.lastSeenPlayerPos.length() > 0 ? 
                        userData.lastSeenPlayerPos : gameObjects.submarine.position;
                    
                    const toHuntTarget = new THREE.Vector3().subVectors(huntTarget, shark.position);
                    toHuntTarget.normalize();
                    shark.position.add(toHuntTarget.multiplyScalar(userData.speed));
                    shark.lookAt(huntTarget);
                    
                    // Add some wandering if too far from player
                    if (distance > userData.aggroRange * 1.5) {
                        const wanderAngle = time * 0.001 + shark.id * 0.1;
                        const wanderOffset = new THREE.Vector3(
                            Math.sin(wanderAngle) * 2,
                            Math.sin(wanderAngle * 0.7) * 1,
                            Math.cos(wanderAngle) * 2
                        );
                        shark.position.add(wanderOffset);
                    }
                    break;
                    
                case 'circling':
                    userData.circleAngle += 0.035;
                    const circleX = gameObjects.submarine.position.x + Math.cos(userData.circleAngle) * userData.circleRadius;
                    const circleZ = gameObjects.submarine.position.z + Math.sin(userData.circleAngle) * userData.circleRadius;
                    const circleY = gameObjects.submarine.position.y + Math.sin(userData.circleAngle * 2) * 3;
                    const circleTarget = new THREE.Vector3(circleX, circleY, circleZ);
                    
                    const toCircle = new THREE.Vector3().subVectors(circleTarget, shark.position);
                    toCircle.normalize();
                    shark.position.add(toCircle.multiplyScalar(userData.speed * 1.2));
                    
                    // Look slightly ahead of the submarine for more realistic behavior
                    const lookAhead = new THREE.Vector3().copy(gameObjects.submarine.position);
                    const subVelocity = new THREE.Vector3(0, 0, 1).applyQuaternion(gameObjects.submarine.quaternion);
                    lookAhead.add(subVelocity.multiplyScalar(10));
                    shark.lookAt(lookAhead);
                    
                    // Chance to break into attack
                    if (Math.random() < 0.015) {
                        userData.state = 'attacking';
                        userData.chaseBoost = 1.8;
                    }
                    break;
                    
                case 'pounceCharging':
                    // Charge up for a powerful pounce attack
                    const chargeTime = time - userData.pounceTime;
                    if (chargeTime > 1500) { // 1.5 second charge
                        userData.state = 'attacking';
                        userData.chaseBoost = 3.0; // Very fast pounce
                    } else {
                        // Slight movement during charge, building tension
                        const chargeIntensity = chargeTime / 1500;
                        shark.rotation.z += Math.sin(time * 0.02) * chargeIntensity * 0.3;
                        
                        // Gradually orient towards player
                        const chargeTarget = new THREE.Vector3().subVectors(gameObjects.submarine.position, shark.position);
                        chargeTarget.normalize().multiplyScalar(userData.speed * 0.3 * chargeIntensity);
                        shark.position.add(chargeTarget);
                        shark.lookAt(gameObjects.submarine.position);
                    }
                    break;
                    
                case 'attacking':
                    // Enhanced attack with prediction
                    const subVelocityEstimate = new THREE.Vector3(0, 0, 1).applyQuaternion(gameObjects.submarine.quaternion);
                    if (moveForward) subVelocityEstimate.multiplyScalar(0.6);
                    else if (moveBackward) subVelocityEstimate.multiplyScalar(-0.42);
                    else subVelocityEstimate.multiplyScalar(0);
                    
                    const predictedPos = new THREE.Vector3().copy(gameObjects.submarine.position);
                    predictedPos.add(subVelocityEstimate.multiplyScalar(distance / (userData.speed * userData.chaseBoost * 60))); // Predict where sub will be
                    
                    const toPredicted = new THREE.Vector3().subVectors(predictedPos, shark.position);
                    toPredicted.normalize();
                    shark.position.add(toPredicted.multiplyScalar(userData.speed * userData.chaseBoost));
                    shark.lookAt(predictedPos);
                    
                    // Gradually reduce chase boost
                    userData.chaseBoost = Math.max(1.0, userData.chaseBoost * 0.995);
                    
                    if (distance < userData.attackRange) {
                        const currentTime = Date.now();
                        if (currentTime - userData.lastAttackTime > userData.attackCooldown) {
                            damageSubmarine(userData.attackDamage);
                            userData.lastAttackTime = currentTime;
                            userData.state = 'circling';
                            userData.circleRadius = 12 + Math.random() * 8;
                            userData.chaseBoost = 1.0;
                            
                            // Create visual attack effect
                            const attackFlash = new THREE.PointLight(0xff4444, 4, 25);
                            attackFlash.position.copy(shark.position);
                            scene.add(attackFlash);
                            setTimeout(() => scene.remove(attackFlash), 300);
                            
                            console.log(`🦈 Shark attacked! Damage: ${userData.attackDamage}, Sub health: ${submarineHealth}`);
                        }
                    }
                    break;
            }
            
            // Enhanced collision avoidance with terrain
            const terrainHeight = getHeight(shark.position.x, shark.position.z);
            if (shark.position.y < terrainHeight + 3) {
                shark.position.y = terrainHeight + 3;
            }
            
            // Avoid other sharks
            sharks.forEach(otherShark => {
                if (otherShark !== shark) {
                    const toOther = new THREE.Vector3().subVectors(otherShark.position, shark.position);
                    const otherDistance = toOther.length();
                    if (otherDistance < 8 && otherDistance > 0) {
                        const avoidance = toOther.normalize().multiplyScalar(-0.3);
                        shark.position.add(avoidance);
                    }
                }
            });
        }

        function updateTurtleAI(turtle, time) {
            const userData = turtle.userData;
            
            // Enhanced wandering behavior
            userData.wanderAngle += (Math.random() - 0.5) * 0.08;
            
            const moveX = Math.cos(userData.wanderAngle) * userData.speed;
            const moveZ = Math.sin(userData.wanderAngle) * userData.speed;
            
            userData.currentDirection.set(moveX, 0, moveZ);
            turtle.position.add(userData.currentDirection);
            
            // Enhanced swimming animation with flipper movement
            userData.swimAnimation += 0.03;
            turtle.position.y += Math.sin(userData.swimAnimation) * 0.02;
            turtle.rotation.x = Math.sin(userData.swimAnimation * 0.6) * 0.1;
            turtle.rotation.z = Math.sin(userData.swimAnimation * 0.4) * 0.05;
            
            // Animate flippers
            if (userData.flippers) {
                userData.flippers.forEach((flipper, index) => {
                    const flipperPhase = userData.swimAnimation + index * Math.PI / 2;
                    flipper.rotation.x = Math.sin(flipperPhase * 2) * 0.3;
                    flipper.rotation.z = Math.sin(flipperPhase * 1.5) * 0.2;
                });
            }
            
            // Enhanced avoidance behavior
            if (gameObjects.submarine) {
                const toSubmarine = new THREE.Vector3().subVectors(gameObjects.submarine.position, turtle.position);
                const subDistance = toSubmarine.length();
                
                if (subDistance < userData.avoidanceRadius) {
                    const avoidDirection = toSubmarine.normalize().multiplyScalar(-0.4);
                    turtle.position.add(avoidDirection);
                    userData.wanderAngle = Math.atan2(avoidDirection.z, avoidDirection.x);
                    
                    // Panic animation when too close
                    turtle.rotation.y += Math.sin(time * 0.01) * 0.1;
                }
            }
            
            // Avoid sharks
            sharks.forEach(shark => {
                const toShark = new THREE.Vector3().subVectors(shark.position, turtle.position);
                const sharkDistance = toShark.length();
                if (sharkDistance < userData.avoidanceRadius * 1.5) {
                    const avoidShark = toShark.normalize().multiplyScalar(-0.6);
                    turtle.position.add(avoidShark);
                    userData.wanderAngle = Math.atan2(avoidShark.z, avoidShark.x);
                }
            });
            
            // Terrain collision
            const terrainHeight = getHeight(turtle.position.x, turtle.position.z);
            if (turtle.position.y < terrainHeight + 2) {
                turtle.position.y = terrainHeight + 2;
                userData.wanderAngle += Math.PI / 4; // Turn away from terrain
            }
            
            turtle.lookAt(turtle.position.x + moveX * 10, turtle.position.y, turtle.position.z + moveZ * 10);
        }

        function updateJellyfishAI(jellyfish, time) {
            const userData = jellyfish.userData;
            
            // Enhanced pulsing animation
            userData.pulsePhase += 0.05;
            const pulse = Math.sin(userData.pulsePhase) * 0.2 + 1;
            jellyfish.scale.setScalar(pulse);
            
            // Enhanced tentacle animation with more realistic movement
            userData.tentacles.forEach((tentacle, index) => {
                const tentaclePhase = userData.pulsePhase + index * 0.5;
                const baseRotation = Math.sin(tentaclePhase) * 0.4;
                tentacle.rotation.z = baseRotation;
                tentacle.rotation.x = Math.sin(tentaclePhase * 0.7) * 0.3;
                
                // Animate individual segments for more realistic tentacle movement
                if (tentacle.userData && tentacle.userData.segments) {
                    tentacle.userData.segments.forEach((segment, segIndex) => {
                        const segmentPhase = tentaclePhase + segIndex * 0.4;
                        segment.rotation.x = Math.sin(segmentPhase) * 0.2 * (segIndex + 1) / 8;
                        segment.rotation.z = Math.cos(segmentPhase * 0.8) * 0.15 * (segIndex + 1) / 8;
                    });
                }
            });
            
            // Enhanced movement with current simulation
            userData.driftAngle += 0.02;
            userData.verticalPhase += 0.03;
            
            const currentX = Math.cos(userData.driftAngle) * userData.speed;
            const currentZ = Math.sin(userData.driftAngle) * userData.speed;
            const currentY = Math.sin(userData.verticalPhase) * 0.03;
            
            jellyfish.position.x += currentX;
            jellyfish.position.z += currentZ;
            jellyfish.position.y += currentY;
            
            // Enhanced bioluminescent glow based on proximity to submarine
            if (userData.glowLight && gameObjects.submarine) {
                const distance = jellyfish.position.distanceTo(gameObjects.submarine.position);
                const glowIntensity = Math.max(1, 3 - distance / 15);
                userData.glowLight.intensity = glowIntensity * (0.8 + Math.sin(userData.pulsePhase * 2) * 0.4);
            }
            
            // Enhanced avoidance behavior
            if (gameObjects.submarine) {
                const toSubmarine = new THREE.Vector3().subVectors(gameObjects.submarine.position, jellyfish.position);
                const subDistance = toSubmarine.length();
                
                if (subDistance < userData.avoidanceRadius) {
                    const avoidDirection = toSubmarine.normalize().multiplyScalar(-0.2);
                    jellyfish.position.add(avoidDirection);
                    userData.driftAngle = Math.atan2(avoidDirection.z, avoidDirection.x);
                    
                    // Defensive pulsing when threatened
                    if (userData.glowLight) {
                        userData.glowLight.intensity = 4;
                        userData.glowLight.color.setHex(0xff6666); // Warning red
                        setTimeout(() => {
                            if (userData.glowLight) userData.glowLight.color.setHex(0x88ccff);
                        }, 500);
                    }
                }
            }
            
            // Terrain collision
            const terrainHeight = getHeight(jellyfish.position.x, jellyfish.position.z);
            if (jellyfish.position.y < terrainHeight + 4) {
                jellyfish.position.y = terrainHeight + 4;
                userData.verticalPhase += Math.PI / 3; // Change vertical movement
            }
        }

        // Generate cell content for ocean objects
        function generateCell(cellX, cellZ) {
            const cellKey = `${cellX}-${cellZ}`;
            if (generatedCells.has(cellKey)) return;
            
            generatedCells.set(cellKey, true);
            const objects = { kelp: [], fish: [], rocks: [], shipwrecks: [], sinkholes: [], plankton: [] };
            cellObjects.set(cellKey, objects);
            
            const centerX = cellX * cellSize;
            const centerZ = cellZ * cellSize;
            
            // Generate sinkhole entrances
            const sinkholes = findSinkholes(centerX, centerZ, cellSize / 2);
            
            if (sinkholes.length === 0 && (cellX % 4 === 0 && cellZ % 4 === 0)) {
                const forcedSinkhole = {
                    x: centerX + (Math.random() - 0.5) * cellSize * 0.4,
                    z: centerZ + (Math.random() - 0.5) * cellSize * 0.4,
                    y: getHeight(centerX, centerZ) - 8,
                    key: `forced-${cellX}-${cellZ}`
                };
                sinkholes.push(forcedSinkhole);
            }
            
            sinkholes.forEach(sinkhole => {
                if (!undergroundCity.sinkholes.has(sinkhole.key)) {
                    const sinkholeEntrance = createSinkholeEntrance(sinkhole.x, sinkhole.z, sinkhole.y);
                    sinkholeEntrance.position.set(sinkhole.x, sinkhole.y, sinkhole.z);
                    scene.add(sinkholeEntrance);
                    objects.sinkholes.push(sinkholeEntrance);
                    undergroundCity.sinkholes.set(sinkhole.key, sinkhole);
                    objectCount++;
                }
            });
            
            // Generate ocean content
            if (currentLayer !== GAME_LAYERS.UNDERGROUND_CITY) {
                const terrainHeight = getHeight(centerX, centerZ);
                
                // Enhanced kelp forests
                if (terrainHeight < -15 && Math.random() < 0.4 * adaptiveQuality) {
                    const kelp = createEnhancedKelp(centerX, centerZ);
                    kelp.position.set(
                        centerX + (Math.random() - 0.5) * cellSize * 0.6,
                        terrainHeight,
                        centerZ + (Math.random() - 0.5) * cellSize * 0.6
                    );
                    scene.add(kelp);
                    objects.kelp.push(kelp);
                    objectCount++;
                }
                
                // Enhanced fish schools
                if (Math.random() < 0.25 * adaptiveQuality) {
                    const fish = createFishSchool(centerX, centerZ);
                    const fishHeight = getHeight(centerX, centerZ) + 12 + Math.random() * 25;
                    fish.position.set(centerX, fishHeight, centerZ);
                    scene.add(fish);
                    objects.fish.push(fish);
                    objectCount++;
                }
                
                // Rock formations
                if (Math.abs(terrainHeight + 10) < 25 && Math.random() < 0.3 * adaptiveQuality) {
                    const rocks = createRockFormation(centerX, centerZ);
                    rocks.position.set(
                        centerX + (Math.random() - 0.5) * cellSize * 0.6,
                        terrainHeight,
                        centerZ + (Math.random() - 0.5) * cellSize * 0.6
                    );
                    scene.add(rocks);
                    objects.rocks.push(rocks);
                    objectCount++;
                }
                
                // Shipwrecks
                if (Math.random() < 0.04 * adaptiveQuality) {
                    const shipwreck = createShipwreck();
                    shipwreck.position.set(
                        centerX + (Math.random() - 0.5) * cellSize * 0.5,
                        terrainHeight,
                        centerZ + (Math.random() - 0.5) * cellSize * 0.5
                    );
                    shipwreck.rotation.y = Math.random() * Math.PI * 2;
                    scene.add(shipwreck);
                    objects.shipwrecks.push(shipwreck);
                    objectCount++;
                }
                
                // Enhanced plankton systems
                if (Math.random() < 0.6 * adaptiveQuality) {
                    const plankton = createPlanktonSystem(centerX, centerZ);
                    const planktonHeight = getHeight(centerX, centerZ) + 8 + Math.random() * 20;
                    plankton.position.set(centerX, planktonHeight, centerZ);
                    scene.add(plankton);
                    objects.plankton.push(plankton);
                    planktonSystems.push(plankton);
                    objectCount++;
                }
            }
        }

        function populateWorld() {
            const subPosition = gameObjects.submarine.position;
            const subCellX = Math.floor(subPosition.x / cellSize);
            const subCellZ = Math.floor(subPosition.z / cellSize);
            const activeCells = new Set();
            
            let generationCount = 0;
            const maxGenerationsPerFrame = Math.max(1, Math.floor(0.5 * adaptiveQuality));
            
            for (let dx = -viewRadius; dx <= viewRadius; dx++) {
                for (let dz = -viewRadius; dz <= viewRadius; dz++) {
                    const cellX = subCellX + dx;
                    const cellZ = subCellZ + dz;
                    const cellKey = `${cellX}-${cellZ}`;
                    activeCells.add(cellKey);
                    
                    if (!generatedCells.has(cellKey) && generationCount < maxGenerationsPerFrame) {
                        generateCell(cellX, cellZ);
                        generationCount++;
                    }
                }
            }
            
            // Cleanup distant cells
            let cleanupCount = 0;
            const maxCleanupPerFrame = Math.max(1, Math.floor(1 * adaptiveQuality));
            
            for (const [cellKey, objects] of cellObjects) {
                if (!activeCells.has(cellKey) && cleanupCount < maxCleanupPerFrame) {
                    [...objects.kelp, ...objects.fish, ...objects.rocks, ...objects.shipwrecks, ...objects.sinkholes, ...objects.plankton].forEach(obj => {
                        scene.remove(obj);
                        objectCount--;
                        
                        // Remove from plankton systems if applicable
                        const planktonIndex = planktonSystems.indexOf(obj);
                        if (planktonIndex !== -1) {
                            planktonSystems.splice(planktonIndex, 1);
                        }
                    });
                    cellObjects.delete(cellKey);
                    generatedCells.delete(cellKey);
                    cleanupCount++;
                }
            }
        }

        function animateOceanLife(time) {
            if (currentLayer === GAME_LAYERS.UNDERGROUND_CITY) return;
            
            const t = time * 0.001;
            
            if (frameCount % Math.ceil(3 / adaptiveQuality) !== 0) return;
            
            for (const [cellKey, objects] of cellObjects) {
                // Animate enhanced kelp forests
                objects.kelp.forEach(kelpGroup => {
                    kelpGroup.children.forEach(kelp => {
                        if (kelp.userData && kelp.userData.segments) {
                            kelp.userData.segments.forEach((segment, segIndex) => {
                                const segmentData = segment.userData;
                                if (segmentData) {
                                    const swayPhase = t * segmentData.swaySpeed + segmentData.segmentIndex * 0.3;
                                    const swayX = Math.sin(swayPhase) * segmentData.swayAmplitude * (segmentData.segmentIndex + 1) / 10;
                                    const swayZ = Math.cos(swayPhase * 0.7) * segmentData.swayAmplitude * 0.5 * (segmentData.segmentIndex + 1) / 10;
                                    
                                    segment.position.x = segmentData.baseSwayX + swayX;
                                    segment.position.z = segmentData.baseSwayZ + swayZ;
                                    segment.rotation.x = swayX * 0.3;
                                    segment.rotation.z = swayZ * 0.2;
                                }
                            });
                        }
                    });
                });
                
                // Animate enhanced fish schools
                objects.fish.forEach(school => {
                    if (school.userData && school.userData.fishes) {
                        const schoolAngle = t * school.userData.schoolSpeed + school.userData.schoolPhase;
                        school.position.x = school.userData.centerX + Math.cos(schoolAngle) * school.userData.schoolRadius;
                        school.position.z = school.userData.centerZ + Math.sin(schoolAngle) * school.userData.schoolRadius;
                        school.rotation.y = -schoolAngle + Math.PI / 2;
                        
                        if (frameCount % 12 === 0) {
                            school.userData.fishes.forEach((fish, i) => {
                                if (fish.userData) {
                                    const fishT = t * fish.userData.speed + fish.userData.phase;
                                    const basePos = fish.userData.schoolPosition;
                                    
                                    fish.position.y = basePos.y + Math.sin(fishT) * 0.03;
                                    fish.position.x = basePos.x + Math.sin(fishT * 1.2) * 0.5;
                                    fish.position.z = basePos.z + Math.cos(fishT * 0.8) * 0.3;
                                    fish.rotation.z = Math.sin(fishT * 2) * 0.15;
                                    fish.rotation.y = Math.sin(fishT * 0.6) * 0.1;
                                }
                            });
                        }
                    }
                });
                
                // Animate plankton systems
                objects.plankton.forEach(planktonSystem => {
                    if (planktonSystem.userData && planktonSystem.userData.type === 'plankton') {
                        const userData = planktonSystem.userData;
                        userData.driftDirection += 0.01;
                        
                        const driftX = Math.cos(userData.driftDirection) * userData.driftSpeed;
                        const driftZ = Math.sin(userData.driftDirection) * userData.driftSpeed;
                        
                        planktonSystem.position.x += driftX;
                        planktonSystem.position.z += driftZ;
                        
                        // Animate individual particles
                        const positions = planktonSystem.geometry.attributes.position.array;
                        const originalPositions = userData.originalPositions;
                        
                        for (let i = 0; i < userData.particleCount; i++) {
                            const i3 = i * 3;
                            const swirl = t * 0.5 + i * 0.1;
                            
                            positions[i3] = originalPositions[i3] + Math.sin(swirl) * 2;
                            positions[i3 + 1] = originalPositions[i3 + 1] + Math.sin(swirl * 0.7) * 1.5;
                            positions[i3 + 2] = originalPositions[i3 + 2] + Math.cos(swirl) * 2;
                        }
                        
                        planktonSystem.geometry.attributes.position.needsUpdate = true;
                    }
                });
            }
        }

        // ========== ENHANCED LIGHTING UPDATE ==========
        function updateUnderwaterLighting() {
            if (currentLayer !== GAME_LAYERS.UNDERWATER) return;
            
            const time = Date.now() * 0.001;
            
            // Enhanced underwater lighting effects without custom shaders
            if (gameObjects.submarine && spotlights.length > 0) {
                // Update spotlight intensity based on depth
                const depth = Math.abs(gameObjects.submarine.position.y);
                const depthFactor = Math.max(0.3, 1.0 - (depth / 200));
                
                spotlights.forEach(light => {
                    if (headlightsOn) {
                        light.intensity = 4 * depthFactor;
                        light.distance = 150 * depthFactor;
                    }
                });
                
                // Add subtle color variation to lights based on depth
                const deepColor = new THREE.Color(0x4477bb);
                const shallowColor = new THREE.Color(0xffffcc);
                const currentColor = shallowColor.clone().lerp(deepColor, depth / 100);
                
                spotlights.forEach(light => {
                    light.color = currentColor;
                });
            }
        }

        function updateCamera() {
            if (!gameObjects.player) return;
            
            if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                // Dynamic aircraft camera
                cameraDistance = Math.min(cameraDistance, 100);
                cameraDistance = Math.max(cameraDistance, 20);
                
                const bankingOffset = gameObjects.aircraft ? aircraftState.banking * 0.4 : 0;
                cameraAngleV = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraAngleV));
                
                const cameraOffset = new THREE.Vector3(
                    Math.sin(cameraAngleH + bankingOffset) * Math.cos(cameraAngleV) * cameraDistance,
                    Math.sin(cameraAngleV) * cameraDistance,
                    Math.cos(cameraAngleH + bankingOffset) * Math.cos(cameraAngleV) * cameraDistance
                );
                
                camera.position.copy(gameObjects.player.position).add(cameraOffset);
                camera.lookAt(gameObjects.player.position);
                
            } else {
                // Enhanced camera for submarine/surface/underground
                cameraDistance = Math.max(cameraDistance, 8);
                cameraDistance = Math.min(cameraDistance, 100);
                cameraAngleV = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleV));
                
                const cameraOffset = new THREE.Vector3(
                    Math.sin(cameraAngleH) * Math.cos(cameraAngleV) * cameraDistance,
                    Math.sin(cameraAngleV) * cameraDistance,
                    Math.cos(cameraAngleH) * Math.cos(cameraAngleV) * cameraDistance
                );
                
                camera.position.copy(gameObjects.player.position).add(cameraOffset);
                camera.lookAt(gameObjects.player.position);
            }
        }

        function updateLighting(layer) {
            scene.children.forEach(child => {
                if (child instanceof THREE.DirectionalLight) {
                    switch (layer) {
                        case 'underwater':
                            child.intensity = 0.7;
                            child.color.setHex(0x4499dd);
                            child.position.set(50, 100, 50);
                            break;
                        case 'surface':
                            child.intensity = 1.0;
                            child.color.setHex(0xffffff);
                            child.position.set(100, 150, 100);
                            break;
                        case 'aircraft':
                            child.intensity = 1.2;
                            child.color.setHex(0xffffee);
                            child.position.set(200, 300, 200);
                            break;
                        case 'underground':
                            child.intensity = 0.4;
                            child.color.setHex(0x3333aa);
                            child.position.set(50, 100, 50);
                            break;
                    }
                }
                if (child instanceof THREE.AmbientLight) {
                    switch (layer) {
                        case 'underwater':
                            child.intensity = 0.35;
                            child.color.setHex(0x203050);
                            break;
                        case 'surface':
                            child.intensity = 0.5;
                            child.color.setHex(0x404040);
                            break;
                        case 'aircraft':
                            child.intensity = 0.6;
                            child.color.setHex(0x505050);
                            break;
                        case 'underground':
                            child.intensity = 0.3;
                            child.color.setHex(0x332244);
                            break;
                    }
                }
            });
        }

        // ========== UI FUNCTIONS ==========
        function updateAircraftDisplay() {
            const aircraft = aircraftTypes[selectedAircraftType];
            const display = document.getElementById('aircraft-display');
            
            const getStars = (rating) => '★'.repeat(rating) + '☆'.repeat(5-rating);
            
            display.innerHTML = `
                <div class="aircraft-name">${aircraft.name}</div>
                <div class="aircraft-stats">
                    <div class="stat-item">
                        <div class="stat-label">MAX SPEED</div>
                        <div class="stat-value">${aircraft.maxSpeed.toFixed(1)} kts</div>
                        <div class="star-rating">${getStars(aircraft.stats.speed)}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">AGILITY</div>
                        <div class="stat-value">${aircraft.agility.toFixed(3)}</div>
                        <div class="star-rating">${getStars(aircraft.stats.agility)}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">ALTITUDE</div>
                        <div class="stat-value">Service Ceiling</div>
                        <div class="star-rating">${getStars(aircraft.stats.altitude)}</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">STABILITY</div>
                        <div class="stat-value">Flight Control</div>
                        <div class="star-rating">${getStars(aircraft.stats.stability)}</div>
                    </div>
                </div>
                <div class="aircraft-special">
                    <strong>🎯 Special Capability:</strong> ${aircraft.special}
                </div>
            `;
        }

        function cycleAircraft(direction) {
            const types = Object.keys(aircraftTypes);
            const currentIndex = types.indexOf(selectedAircraftType);
            let newIndex = currentIndex + direction;
            
            if (newIndex < 0) newIndex = types.length - 1;
            if (newIndex >= types.length) newIndex = 0;
            
            selectedAircraftType = types[newIndex];
            updateAircraftDisplay();
            console.log(`✈️ Selected aircraft: ${aircraftTypes[selectedAircraftType].name}`);
        }

        function launchSelectedAircraft() {
            console.log(`🚀 Launching ${aircraftTypes[selectedAircraftType].name}`);
            layerManager.transitionTo(GAME_LAYERS.AIRCRAFT, 3000);
        }

        function updateFlightHUD() {
            if (currentLayer !== GAME_LAYERS.AIRCRAFT) return;
            
            document.getElementById('altitude-indicator').textContent = `ALT: ${Math.round(aircraftState.altitude)}m`;
            document.getElementById('speed-indicator').textContent = `SPD: ${aircraftState.speed.toFixed(1)} kts`;
            
            const heading = (gameObjects.aircraft.rotation.y * 180 / Math.PI + 360) % 360;
            document.getElementById('heading-indicator').textContent = `HDG: ${Math.round(heading).toString().padStart(3, '0')}°`;
            
            document.getElementById('throttle-indicator').textContent = `THR: ${Math.round(aircraftState.throttle * 100)}%`;
            
            // Update artificial horizon
            const horizonLine = document.querySelector('.horizon-line');
            if (horizonLine) {
                horizonLine.style.transform = `rotate(${-aircraftState.banking * 30}deg)`;
            }
            
            updateHealthBar();
        }

        function showLayerIndicator(text, show) {
            const indicator = document.getElementById('layer-indicator');
            if (show && text) {
                indicator.textContent = text;
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }

        function updateUI() {
            const player = gameObjects.player;
            if (!player) return;
            
            // Update depth display
            const depth = Math.abs(player.position.y);
            const depthColor = depth > 100 ? '#ffaa44' : depth > 50 ? '#4499dd' : '#44ff44';
            document.getElementById('depth').textContent = depth.toFixed(1);
            document.getElementById('depth-value').textContent = depth.toFixed(1);
            document.getElementById('depth-indicator').style.borderColor = depthColor;
            document.getElementById('depth-indicator').style.color = depthColor;
            
            document.getElementById('position').textContent = 
                `${player.position.x.toFixed(1)}, ${player.position.z.toFixed(1)}`;
            
            // Layer-specific UI updates
            switch (currentLayer) {
                case GAME_LAYERS.UNDERWATER:
                    document.getElementById('environment').textContent = 'Ocean Depths';
                    document.getElementById('marine-life').textContent = `${sharks.length + turtles.length + jellyfish.length} (🦈${sharks.length})`;
                    document.getElementById('torpedoes').textContent = torpedoes.length;
                    document.getElementById('speed').textContent = '0.6 kts';
                    document.getElementById('status').textContent = 'Submerged';
                    break;
                    
                case GAME_LAYERS.SURFACE:
                    document.getElementById('environment').textContent = 'Ocean Surface';
                    document.getElementById('marine-life').textContent = '0';
                    document.getElementById('torpedoes').textContent = '0';
                    document.getElementById('speed').textContent = '0.6 kts';
                    document.getElementById('status').textContent = 'Surfaced';
                    break;
                    
                case GAME_LAYERS.CARRIER:
                    document.getElementById('environment').textContent = 'Aircraft Carrier';
                    document.getElementById('marine-life').textContent = '0';
                    document.getElementById('torpedoes').textContent = '0';
                    document.getElementById('speed').textContent = '0 kts';
                    document.getElementById('status').textContent = 'Docked';
                    break;
                    
                case GAME_LAYERS.AIRCRAFT:
                    document.getElementById('environment').textContent = 'Aerial Combat';
                    document.getElementById('marine-life').textContent = '0';
                    document.getElementById('torpedoes').textContent = '0';
                    document.getElementById('speed').textContent = `${aircraftState.speed.toFixed(1)} kts`;
                    document.getElementById('status').textContent = aircraftState.stalled ? 'STALLED' : 'Flying';
                    break;
                    
                case GAME_LAYERS.UNDERGROUND_CITY:
                    document.getElementById('environment').textContent = 'Underground City';
                    document.getElementById('marine-life').textContent = '0';
                    document.getElementById('torpedoes').textContent = torpedoes.length;
                    document.getElementById('speed').textContent = '0.6 kts';
                    document.getElementById('status').textContent = 'Exploring';
                    break;
            }
            
            document.getElementById('objects').textContent = objectCount;
            document.getElementById('cities-found').textContent = undergroundCity.sinkholes.size;
        }

        // ========== DAMAGE SYSTEMS ==========
        function damageSubmarine(damage) {
            if (isGameOver) return;
            
            submarineHealth = Math.max(0, submarineHealth - damage);
            updateHealthBar();
            
            const flash = document.getElementById('damage-flash');
            flash.style.opacity = '1';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 200);
            
            console.log(`🔥 Submarine damaged: ${damage} HP (${submarineHealth}/${maxHealth})`);
            
            if (submarineHealth <= 0) {
                gameOver('Submarine Destroyed by Marine Life');
            }
        }

        function damageAircraft(damage) {
            if (isGameOver) return;
            
            aircraftState.fuel = Math.max(0, aircraftState.fuel - damage);
            updateHealthBar();
            
            const flash = document.getElementById('damage-flash');
            flash.style.opacity = '1';
            setTimeout(() => {
                flash.style.opacity = '0';
            }, 200);
            
            console.log(`💥 Aircraft damaged: ${damage} fuel (${aircraftState.fuel}/100)`);
            
            if (aircraftState.fuel <= 0) {
                gameOver('Aircraft Crashed - Fuel Depleted');
            }
        }

        function updateHealthBar() {
            let healthPercent, healthText, healthColor;
            
            if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                healthPercent = aircraftState.fuel;
                healthText = `${Math.floor(aircraftState.fuel)} FUEL`;
                healthColor = healthPercent > 60 ? '#44aa44' : healthPercent > 30 ? '#ffaa44' : '#ff4444';
            } else {
                healthPercent = (submarineHealth / maxHealth) * 100;
                healthText = `${Math.floor(submarineHealth)} HP`;
                healthColor = healthPercent > 60 ? '#44aa44' : healthPercent > 30 ? '#ffaa44' : '#ff4444';
            }
            
            const healthFill = document.getElementById('health-fill');
            const healthTextEl = document.getElementById('health-text');
            
            healthFill.style.width = healthPercent + '%';
            healthTextEl.textContent = healthText;
            healthFill.style.background = `linear-gradient(to right, ${healthColor}, ${healthColor}aa)`;
        }

        function gameOver(reason) {
            isGameOver = true;
            document.getElementById('final-status').textContent = reason;
            document.getElementById('game-over').style.display = 'block';
            console.log(`💀 GAME OVER: ${reason}`);
        }

        // ========== LAYER TRANSITION FUNCTIONS ==========
        function handleLayerTransition() {
            switch (currentLayer) {
                case GAME_LAYERS.UNDERWATER:
                    // Check for surface transition
                    if (gameObjects.submarine.position.y >= 150) {
                        console.log('🌊 Breaking surface at +150m depth');
                        layerManager.transitionTo(GAME_LAYERS.SURFACE);
                    }
                    // Check for underground city transition
                    else if (undergroundCity.nearSinkhole) {
                        console.log('🏙️ Entering underground city');
                        layerManager.transitionTo(GAME_LAYERS.UNDERGROUND_CITY);
                    }
                    break;
                    
                case GAME_LAYERS.SURFACE:
                    if (surfaceSystem.nearCarrier) {
                        layerManager.transitionTo(GAME_LAYERS.CARRIER);
                    } else if (surfaceSystem.nearDiveZone) {
                        layerManager.transitionTo(GAME_LAYERS.UNDERWATER);
                    }
                    break;
                    
                case GAME_LAYERS.CARRIER:
                    launchSelectedAircraft();
                    break;
                    
                case GAME_LAYERS.AIRCRAFT:
                    if (gameObjects.carrier) {
                        const distance = gameObjects.aircraft.position.distanceTo(gameObjects.carrier.position);
                        const altitude = gameObjects.aircraft.position.y - gameObjects.carrier.position.y;
                        if (distance < 40 && altitude < 25) {
                            layerManager.transitionTo(GAME_LAYERS.CARRIER);
                        }
                    }
                    break;
                    
                case GAME_LAYERS.UNDERGROUND_CITY:
                    if (undergroundCity.exitPortal) {
                        const distance = gameObjects.submarine.position.distanceTo(undergroundCity.exitPortal.position);
                        if (distance < 25) {
                            console.log('🌊 Exiting underground city');
                            layerManager.transitionTo(GAME_LAYERS.UNDERWATER);
                        }
                    }
                    break;
            }
        }

        function checkPerformance(currentTime) {
            frameCount++;
            
            if (currentTime - lastPerformanceCheck > 3000) {
                const fps = frameCount / 3;
                frameCount = 0;
                lastPerformanceCheck = currentTime;
                
                if (fps < 25) {
                    adaptiveQuality = Math.max(0.3, adaptiveQuality - 0.1);
                    console.log(`⚠️ Performance low (${fps.toFixed(1)} FPS), reducing quality to ${adaptiveQuality.toFixed(1)}`);
                } else if (fps > 55) {
                    adaptiveQuality = Math.min(1.0, adaptiveQuality + 0.05);
                }
            }
        }

        // ========== CONTROL SETUP ==========
        function setupControls() {
            document.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW': 
                        if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                            moveForward = true;
                        } else {
                            moveForward = true;
                        }
                        break;
                    case 'KeyS': 
                        if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                            moveBackward = true;
                        } else {
                            moveBackward = true;
                        }
                        break;
                    case 'KeyA': 
                        if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                            bankLeft = true;
                        } else if (currentLayer === GAME_LAYERS.CARRIER) {
                            cycleAircraft(-1);
                        } else {
                            turnLeft = true;
                        }
                        break;
                    case 'KeyD': 
                        if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                            bankRight = true;
                        } else if (currentLayer === GAME_LAYERS.CARRIER) {
                            cycleAircraft(1);
                        } else {
                            turnRight = true;
                        }
                        break;
                    case 'Space': 
                        e.preventDefault(); 
                        if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                            throttleUp = true;
                        } else if (currentLayer === GAME_LAYERS.CARRIER) {
                            launchSelectedAircraft();
                        } else {
                            rise = true;
                        }
                        break;
                    case 'ShiftLeft':
                    case 'ShiftRight': 
                        if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                            throttleDown = true;
                        } else {
                            sink = true;
                        }
                        break;
                    case 'KeyQ': 
                        if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                            turnLeft = true;
                        } else {
                            fireTorpedo('left');
                        }
                        break;
                    case 'KeyE': 
                        if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                            turnRight = true;
                        } else {
                            fireTorpedo('right');
                        }
                        break;
                    case 'KeyC':
                        handleLayerTransition();
                        break;
                    case 'KeyH':
                        headlightsOn = !headlightsOn;
                        spotlights.forEach(light => {
                            light.visible = headlightsOn;
                        });
                        console.log(`💡 Headlights ${headlightsOn ? 'ON' : 'OFF'}`);
                        break;
                    case 'KeyT':
                        // Toggle wireframe
                        if (currentLayer === GAME_LAYERS.UNDERGROUND_CITY) {
                            undergroundCity.allCityMeshes.forEach(mesh => {
                                if (mesh.children && mesh.children.length > 0) {
                                    mesh.children.forEach(child => {
                                        if (child.material) {
                                            child.material.wireframe = !child.material.wireframe;
                                        }
                                    });
                                }
                            });
                        } else {
                            environment.chunks.forEach(chunk => {
                                chunk.material.wireframe = !chunk.material.wireframe;
                            });
                        }
                        break;
                    case 'KeyF':
                        // Toggle fog
                        if (scene.fog) {
                            scene.fog = null;
                        } else {
                            let fogColor, fogDensity;
                            switch (currentLayer) {
                                case GAME_LAYERS.UNDERWATER:
                                    fogColor = 0x002244;
                                    fogDensity = 0.004;
                                    break;
                                case GAME_LAYERS.SURFACE:
                                    fogColor = 0x87CEEB;
                                    fogDensity = 0.0012;
                                    break;
                                case GAME_LAYERS.AIRCRAFT:
                                    fogColor = 0xE6F3FF;
                                    fogDensity = 0.0008;
                                    break;
                                case GAME_LAYERS.UNDERGROUND_CITY:
                                    fogColor = 0x221133;
                                    fogDensity = 0.002;
                                    break;
                                default:
                                    fogColor = 0x002244;
                                    fogDensity = 0.004;
                            }
                            scene.fog = new THREE.FogExp2(fogColor, fogDensity);
                        }
                        break;
                    case 'Escape':
                        if (currentLayer === GAME_LAYERS.CARRIER) {
                            layerManager.transitionTo(GAME_LAYERS.SURFACE);
                        }
                        break;
                }
            });
            
            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': turnLeft = false; bankLeft = false; break;
                    case 'KeyD': turnRight = false; bankRight = false; break;
                    case 'Space': rise = false; throttleUp = false; break;
                    case 'ShiftLeft':
                    case 'ShiftRight': sink = false; throttleDown = false; break;
                    case 'KeyQ': turnLeft = false; break;
                    case 'KeyE': turnRight = false; break;
                }
            });

            // Enhanced mouse controls
            document.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
                e.preventDefault();
            });

            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                        cameraAngleH += deltaX * 0.006;
                        cameraAngleV += deltaY * 0.006;
                        
                        aircraftState.banking += deltaX * 0.002;
                        aircraftState.pitching += deltaY * 0.002;
                        
                        aircraftState.banking = Math.max(-1, Math.min(1, aircraftState.banking));
                        aircraftState.pitching = Math.max(-0.6, Math.min(0.6, aircraftState.pitching));
                    } else {
                        cameraAngleH += deltaX * 0.012;
                        cameraAngleV += deltaY * 0.012;
                        cameraAngleV = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleV));
                    }
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });

            document.addEventListener('wheel', (e) => {
                const zoomSpeed = currentLayer === GAME_LAYERS.AIRCRAFT ? 0.08 : 0.05;
                cameraDistance += e.deltaY * zoomSpeed;
                
                const maxDistance = currentLayer === GAME_LAYERS.AIRCRAFT ? 100 : 100;
                const minDistance = currentLayer === GAME_LAYERS.AIRCRAFT ? 20 : 8;
                cameraDistance = Math.max(minDistance, Math.min(maxDistance, cameraDistance));
                e.preventDefault();
            });

            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            setupMobileControls();
        }

        function setupMobileControls() {
            const controlElements = {
                forward: document.getElementById('move-forward'),
                backward: document.getElementById('move-backward'),
                left: document.getElementById('move-left'),
                right: document.getElementById('move-right'),
                up: document.getElementById('move-up'),
                down: document.getElementById('move-down'),
                actionLeft: document.getElementById('action-left'),
                actionRight: document.getElementById('action-right'),
                lights: document.getElementById('toggle-lights')
            };
            
            function setupButton(button, pressAction, releaseAction) {
                if (!button) return;
                
                const onStart = (e) => {
                    e.preventDefault();
                    button.classList.add('pressed');
                    if (pressAction) pressAction();
                };
                
                const onEnd = (e) => {
                    e.preventDefault();
                    button.classList.remove('pressed');
                    if (releaseAction) releaseAction();
                };
                
                button.addEventListener('touchstart', onStart, { passive: false });
                button.addEventListener('touchend', onEnd, { passive: false });
                button.addEventListener('touchcancel', onEnd, { passive: false });
                button.addEventListener('mousedown', onStart);
                button.addEventListener('mouseup', onEnd);
                button.addEventListener('mouseleave', onEnd);
            }
            
            setupButton(controlElements.forward, 
                () => {
                    if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                        moveForward = true;
                    } else {
                        moveForward = true;
                    }
                },
                () => { moveForward = false; }
            );
            
            setupButton(controlElements.backward, 
                () => {
                    if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                        moveBackward = true;
                    } else {
                        moveBackward = true;
                    }
                },
                () => { moveBackward = false; }
            );
            
            setupButton(controlElements.left, 
                () => {
                    if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                        bankLeft = true;
                    } else {
                        turnLeft = true;
                    }
                },
                () => { turnLeft = false; bankLeft = false; }
            );
            
            setupButton(controlElements.right, 
                () => {
                    if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                        bankRight = true;
                    } else {
                        turnRight = true;
                    }
                },
                () => { turnRight = false; bankRight = false; }
            );
            
            setupButton(controlElements.up, 
                () => {
                    if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                        throttleUp = true;
                    } else {
                        rise = true;
                    }
                },
                () => { rise = false; throttleUp = false; }
            );
            
            setupButton(controlElements.down, 
                () => {
                    if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                        throttleDown = true;
                    } else {
                        sink = true;
                    }
                },
                () => { sink = false; throttleDown = false; }
            );
            
            if (controlElements.actionLeft) {
                controlElements.actionLeft.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (currentLayer === GAME_LAYERS.CARRIER) {
                        cycleAircraft(-1);
                    } else if (currentLayer === GAME_LAYERS.UNDERWATER || currentLayer === GAME_LAYERS.UNDERGROUND_CITY) {
                        fireTorpedo('left');
                    }
                }, { passive: false });
            }
            
            if (controlElements.actionRight) {
                controlElements.actionRight.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (currentLayer === GAME_LAYERS.CARRIER) {
                        cycleAircraft(1);
                    } else if (currentLayer === GAME_LAYERS.UNDERWATER || currentLayer === GAME_LAYERS.UNDERGROUND_CITY) {
                        fireTorpedo('right');
                    }
                }, { passive: false });
            }
            
            if (controlElements.lights) {
                controlElements.lights.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    headlightsOn = !headlightsOn;
                    spotlights.forEach(light => {
                        light.visible = headlightsOn;
                    });
                }, { passive: false });
            }
            
            // Enhanced touch camera controls
            let touchStartX = 0, touchStartY = 0, isTouching = false;
            
            document.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('mobile-btn')) return;
                
                if (e.touches.length === 1) {
                    isTouching = true;
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (!isTouching || e.touches.length !== 1) return;
                if (e.target.classList.contains('mobile-btn')) return;
                
                const deltaX = e.touches[0].clientX - touchStartX;
                const deltaY = e.touches[0].clientY - touchStartY;
                
                if (currentLayer === GAME_LAYERS.AIRCRAFT) {
                    cameraAngleH += deltaX * 0.008;
                    cameraAngleV += deltaY * 0.008;
                    
                    aircraftState.banking += deltaX * 0.003;
                    aircraftState.pitching += deltaY * 0.003;
                    
                    aircraftState.banking = Math.max(-1, Math.min(1, aircraftState.banking));
                    aircraftState.pitching = Math.max(-0.6, Math.min(0.6, aircraftState.pitching));
                } else {
                    cameraAngleH += deltaX * 0.015;
                    cameraAngleV += deltaY * 0.015;
                    cameraAngleV = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraAngleV));
                }
                
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                
                e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('touchend', () => {
                isTouching = false;
            }, { passive: true });
        }

        // ========== INITIALIZATION ==========
        function init() {
            console.log('🚀 Initializing Enhanced Multi-Layer Submarine Combat & Exploration...');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x002244, 0.004);
            
            // Enhanced camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 25, 35);
            
            // Enhanced renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x001122);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // Create noise texture for enhanced shaders
            noiseTexture = createNoiseTexture();
            
            // Enhanced lighting system
            const ambientLight = new THREE.AmbientLight(0x203050, 0.35);
            ambientLight.name = 'ambientLight';
            scene.add(ambientLight);
            
            const sunLight = new THREE.DirectionalLight(0x4499dd, 0.7);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.name = 'sunLight';
            scene.add(sunLight);
            
            const hemisphereLight = new THREE.HemisphereLight(0x2266aa, 0x002244, 0.4);
            hemisphereLight.name = 'hemisphereLight';
            scene.add(hemisphereLight);
            
            // Create underwater environment
            environment = createEnvironment();
            environment.chunks.forEach(chunk => scene.add(chunk));
            
            // Create enhanced submarine
            gameObjects.submarine = createSubmarine();
            gameObjects.submarine.position.set(0, 10, 0);
            gameObjects.submarine.rotation.y = Math.PI;
            scene.add(gameObjects.submarine);
            gameObjects.player = gameObjects.submarine;
            
            // Enhanced submarine lighting system - functional spotlights only
            const headlight1 = new THREE.SpotLight(0xffffcc, 5, 200, Math.PI / 6, 0.25);
            headlight1.position.set(-1.5, 0.5, 7);
            headlight1.target.position.set(-1.5, -8, 40);
            headlight1.castShadow = true;
            headlight1.shadow.mapSize.width = 2048;
            headlight1.shadow.mapSize.height = 2048;
            headlight1.shadow.camera.near = 0.5;
            headlight1.shadow.camera.far = 200;
            gameObjects.submarine.add(headlight1);
            gameObjects.submarine.add(headlight1.target);
            spotlights.push(headlight1);
            
            const headlight2 = new THREE.SpotLight(0xffffcc, 5, 200, Math.PI / 6, 0.25);
            headlight2.position.set(1.5, 0.5, 7);
            headlight2.target.position.set(1.5, -8, 40);
            headlight2.castShadow = true;
            headlight2.shadow.mapSize.width = 2048;
            headlight2.shadow.mapSize.height = 2048;
            headlight2.shadow.camera.near = 0.5;
            headlight2.shadow.camera.far = 200;
            gameObjects.submarine.add(headlight2);
            gameObjects.submarine.add(headlight2.target);
            spotlights.push(headlight2);
            
            // Enhanced submarine ambient glow
            const subGlow = new THREE.PointLight(0xffff88, 1.5, 35);
            subGlow.position.set(0, 0, 0);
            gameObjects.submarine.add(subGlow);
            
            // Enhanced navigation lights
            const redLight = new THREE.PointLight(0xff0000, 1.2, 25);
            redLight.position.set(-2.5, 0, 0);
            gameObjects.submarine.add(redLight);
            
            const greenLight = new THREE.PointLight(0x00ff00, 1.2, 25);
            greenLight.position.set(2.5, 0, 0);
            gameObjects.submarine.add(greenLight);
            
            // Performance monitoring
            stats = new Stats();
            stats.domElement.style.cssText = 'position:absolute;top:0;left:0;z-index:100;';
            document.getElementById('stats').appendChild(stats.domElement);
            
            // Initialize controls
            setupControls();
            
            // Initialize aircraft selection
            updateAircraftDisplay();
            
            console.log('✅ Enhanced multi-layer system initialized successfully!');
            console.log('🎮 Navigate between 5 layers: Underwater ↔ Surface ↔ Carrier ↔ Aircraft + Underground Cities');
            console.log('🏙️ Find sinkholes underwater (press C) to explore underground cities!');
            console.log('✈️ Launch aircraft from carriers for aerial combat!');
            console.log('🌊 Enhanced underwater experience with volumetric lighting and smart AI!');
            console.log('🦈 Intelligent sharks with pounce attacks and jellyfish with animated tentacles!');
            
            animate();
        }

        // ========== MAIN ANIMATION LOOP ==========
        function animate(time = 0) {
            requestAnimationFrame(animate);
            
            stats.begin();
            
            checkPerformance(time);
            
            // Update enhanced underwater lighting
            updateUnderwaterLighting();
            
            // Layer-specific updates
            switch (currentLayer) {
                case GAME_LAYERS.UNDERWATER:
                    updateSubmarine();
                    updateTorpedoes();
                    
                    // Sinkhole proximity check (throttled)
                    const currentTime = Date.now();
                    if (currentTime - undergroundCity.lastSinkholeCheck > 500) {
                        checkSinkholeProximity();
                        undergroundCity.lastSinkholeCheck = currentTime;
                    }
                    
                    // Enhanced marine life management
                    if (frameCount % Math.ceil(45 / adaptiveQuality) === 0) {
                        spawnMarineLife();
                    }
                    
                    // Ensure shark AI updates every frame for responsive behavior
                    if (frameCount % Math.ceil(2 / adaptiveQuality) === 0) {
                        // Clean up dead sharks first
                        for (let i = sharks.length - 1; i >= 0; i--) {
                            if (sharks[i].userData.health <= 0) {
                                scene.remove(sharks[i]);
                                sharks.splice(i, 1);
                                console.log('🦈 Removed dead shark from scene');
                            }
                        }
                        
                        sharks.forEach((shark, index) => {
                            if (shark.visible && shark.userData.health > 0) {
                                updateSharkAI(shark, time);
                            }
                        });
                        turtles.forEach(turtle => {
                            if (turtle.visible) {
                                updateTurtleAI(turtle, time);
                            }
                        });
                        jellyfish.forEach(jelly => {
                            if (jelly.visible) {
                                updateJellyfishAI(jelly, time);
                            }
                        });
                    }
                    break;
                    
                case GAME_LAYERS.SURFACE:
                    updateSubmarine();
                    updateSurface();
                    break;
                    
                case GAME_LAYERS.CARRIER:
                    // Animate carrier elements
                    if (gameObjects.carrier) {
                        gameObjects.carrier.children.forEach(child => {
                            if (child.dish) {
                                child.dish.rotation.y += 0.015;
                            }
                        });
                    }
                    break;
                    
                case GAME_LAYERS.AIRCRAFT:
                    updateAircraft();
                    checkCarrierLanding();
                    
                    // Animate sky elements
                    skySystem.clouds.forEach(cloud => {
                        if (cloud.userData) {
                            cloud.userData.bobPhase += cloud.userData.verticalBob;
                            cloud.position.x += Math.cos(cloud.userData.driftDirection) * cloud.userData.driftSpeed;
                            cloud.position.z += Math.sin(cloud.userData.driftDirection) * cloud.userData.driftSpeed;
                            cloud.position.y += Math.sin(cloud.userData.bobPhase) * 0.1;
                        }
                    });
                    break;
                    
                case GAME_LAYERS.UNDERGROUND_CITY:
                    updateSubmarine();
                    updateTorpedoes();
                    
                    // Check exit portal proximity
                    checkExitProximity();
                    
                    // Throttled city generation
                    if (frameCount % Math.ceil(10 / adaptiveQuality) === 0) {
                        updateCityGeneration();
                    }
                    break;
            }
            
            updateExplosions();
            
            // Throttled world population (ocean objects)
            if ((currentLayer === GAME_LAYERS.UNDERWATER || currentLayer === GAME_LAYERS.SURFACE) && 
                frameCount % Math.ceil(5 / adaptiveQuality) === 0) {
                populateWorld();
            }
            
            // Enhanced ocean life animation
            animateOceanLife(time);
            
            // Update plankton systems
            planktonSystems.forEach((plankton, index) => {
                if (plankton.userData && plankton.userData.type === 'plankton') {
                    const userData = plankton.userData;
                    
                    // Animate plankton drift
                    userData.driftDirection += 0.005;
                    const driftX = Math.cos(userData.driftDirection) * userData.driftSpeed;
                    const driftZ = Math.sin(userData.driftDirection) * userData.driftSpeed;
                    
                    plankton.position.x += driftX;
                    plankton.position.z += driftZ;
                    
                    // Add some vertical movement
                    plankton.position.y += Math.sin(time * 0.001 + index) * 0.02;
                }
            });
            
            updateCamera();
            updateUI();
            
            renderer.render(scene, camera);
            
            stats.end();
        }

        // ========== RESIZE HANDLER ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== START APPLICATION ==========
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>